import { getAnalytics } from './chunk-OQQFOUQW.js';
import * as fs3 from 'fs';
import fs3__default, { existsSync } from 'fs';
import fs4 from 'fs/promises';
import * as p from '@clack/prompts';
import color2 from 'picocolors';
import child_process from 'child_process';
import util from 'util';
import path from 'path';
import shellQuote2 from 'shell-quote';
import yoctoSpinner2 from 'yocto-spinner';
import { InvalidArgumentError } from 'commander';
import os from 'os';
import fsExtra, { readJSON, ensureFile, writeJSON } from 'fs-extra/esm';
import prettier from 'prettier';
import { execa } from 'execa';
import { fileURLToPath } from 'url';
import { PinoLogger } from '@mastra/loggers';

var args = ["-y", "@mastra/mcp-docs-server"];
var createMcpConfig = (editor) => {
  if (editor === "vscode") {
    return {
      servers: {
        mastra: process.platform === `win32` ? {
          command: "cmd",
          args: ["/c", "npx", ...args],
          type: "stdio"
        } : {
          command: "npx",
          args,
          type: "stdio"
        }
      }
    };
  }
  return {
    mcpServers: {
      mastra: {
        command: "npx",
        args
      }
    }
  };
};
function makeConfig(original, editor) {
  if (editor === "vscode") {
    return {
      ...original,
      servers: {
        ...original?.servers || {},
        ...createMcpConfig(editor).servers
      }
    };
  }
  return {
    ...original,
    mcpServers: {
      ...original?.mcpServers || {},
      ...createMcpConfig(editor).mcpServers
    }
  };
}
async function writeMergedConfig(configPath, editor) {
  const configExists = existsSync(configPath);
  const config = makeConfig(configExists ? await readJSON(configPath) : {}, editor);
  await ensureFile(configPath);
  await writeJSON(configPath, config, {
    spaces: 2
  });
}
var windsurfGlobalMCPConfigPath = path.join(os.homedir(), ".codeium", "windsurf", "mcp_config.json");
var cursorGlobalMCPConfigPath = path.join(os.homedir(), ".cursor", "mcp.json");
path.join(process.cwd(), ".vscode", "mcp.json");
var vscodeGlobalMCPConfigPath = path.join(
  os.homedir(),
  process.platform === "win32" ? path.join("AppData", "Roaming", "Code", "User", "settings.json") : process.platform === "darwin" ? path.join("Library", "Application Support", "Code", "User", "settings.json") : path.join(".config", "Code", "User", "settings.json")
);
var EDITOR = ["cursor", "cursor-global", "windsurf", "vscode"];
function isValidEditor(value) {
  return EDITOR.includes(value);
}
async function installMastraDocsMCPServer({ editor, directory }) {
  if (editor === `cursor`) {
    await writeMergedConfig(path.join(directory, ".cursor", "mcp.json"), "cursor");
  }
  if (editor === `vscode`) {
    await writeMergedConfig(path.join(directory, ".vscode", "mcp.json"), "vscode");
  }
  if (editor === `cursor-global`) {
    const alreadyInstalled = await globalMCPIsAlreadyInstalled(editor);
    if (alreadyInstalled) {
      return;
    }
    await writeMergedConfig(cursorGlobalMCPConfigPath, "cursor-global");
  }
  if (editor === `windsurf`) {
    const alreadyInstalled = await globalMCPIsAlreadyInstalled(editor);
    if (alreadyInstalled) {
      return;
    }
    await writeMergedConfig(windsurfGlobalMCPConfigPath, editor);
  }
}
async function globalMCPIsAlreadyInstalled(editor) {
  let configPath = ``;
  if (editor === "windsurf") {
    configPath = windsurfGlobalMCPConfigPath;
  } else if (editor === "cursor-global") {
    configPath = cursorGlobalMCPConfigPath;
  } else if (editor === "vscode") {
    configPath = vscodeGlobalMCPConfigPath;
  }
  if (!configPath || !existsSync(configPath)) {
    return false;
  }
  try {
    const configContents = await readJSON(configPath);
    if (!configContents) return false;
    if (editor === "vscode") {
      if (!configContents.servers) return false;
      const hasMastraMCP2 = Object.values(configContents.servers).some(
        (server) => server?.args?.find((arg) => arg?.includes(`@mastra/mcp-docs-server`))
      );
      return hasMastraMCP2;
    }
    if (!configContents?.mcpServers) return false;
    const hasMastraMCP = Object.values(configContents.mcpServers).some(
      (server) => server?.args?.find((arg) => arg?.includes(`@mastra/mcp-docs-server`))
    );
    return hasMastraMCP;
  } catch {
    return false;
  }
}

// src/utils/package-manager.ts
function getPackageManagerAddCommand(pm) {
  switch (pm) {
    case "npm":
      return "install --audit=false --fund=false --loglevel=error --progress=false --update-notifier=false";
    case "yarn":
      return "add";
    case "pnpm":
      return "add --loglevel=error";
    case "bun":
      return "add";
    default:
      return "add";
  }
}

// src/services/service.deps.ts
var DepsService = class {
  packageManager;
  constructor() {
    this.packageManager = this.getPackageManager();
  }
  findLockFile(dir) {
    const lockFiles = ["pnpm-lock.yaml", "package-lock.json", "yarn.lock", "bun.lock"];
    for (const file of lockFiles) {
      if (fs3__default.existsSync(path.join(dir, file))) {
        return file;
      }
    }
    const parentDir = path.resolve(dir, "..");
    if (parentDir !== dir) {
      return this.findLockFile(parentDir);
    }
    return null;
  }
  getPackageManager() {
    const lockFile = this.findLockFile(process.cwd());
    switch (lockFile) {
      case "pnpm-lock.yaml":
        return "pnpm";
      case "package-lock.json":
        return "npm";
      case "yarn.lock":
        return "yarn";
      case "bun.lock":
        return "bun";
      default:
        return "npm";
    }
  }
  async installPackages(packages) {
    const pm = this.packageManager;
    const installCommand = getPackageManagerAddCommand(pm);
    const packageList = packages.join(" ");
    return execa(`${pm} ${installCommand} ${packageList}`, {
      all: true,
      shell: true,
      stdio: "inherit"
    });
  }
  async checkDependencies(dependencies) {
    try {
      const packageJsonPath = path.join(process.cwd(), "package.json");
      try {
        await fs4.access(packageJsonPath);
      } catch {
        return "No package.json file found in the current directory";
      }
      const packageJson = JSON.parse(await fs4.readFile(packageJsonPath, "utf-8"));
      for (const dependency of dependencies) {
        if (!packageJson.dependencies || !packageJson.dependencies[dependency]) {
          return `Please install ${dependency} before running this command (${this.packageManager} install ${dependency})`;
        }
      }
      return "ok";
    } catch (err) {
      console.error(err);
      return "Could not check dependencies";
    }
  }
  async getProjectName() {
    try {
      const packageJsonPath = path.join(process.cwd(), "package.json");
      const packageJson = await fs4.readFile(packageJsonPath, "utf-8");
      const pkg = JSON.parse(packageJson);
      return pkg.name;
    } catch (err) {
      throw err;
    }
  }
  async addScriptsToPackageJson(scripts) {
    const packageJson = JSON.parse(await fs4.readFile("package.json", "utf-8"));
    packageJson.scripts = {
      ...packageJson.scripts,
      ...scripts
    };
    await fs4.writeFile("package.json", JSON.stringify(packageJson, null, 2));
  }
};

// src/services/service.env.ts
var EnvService = class {
};

// src/services/service.fileEnv.ts
var FileEnvService = class extends EnvService {
  filePath;
  constructor(filePath) {
    super();
    this.filePath = filePath;
  }
  readFile(filePath) {
    return new Promise((resolve, reject) => {
      fs3.readFile(filePath, "utf8", (err, data) => {
        if (err) reject(err);
        else resolve(data);
      });
    });
  }
  writeFile({ filePath, data }) {
    return new Promise((resolve, reject) => {
      fs3.writeFile(filePath, data, "utf8", (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
  async updateEnvData({
    key,
    value,
    filePath = this.filePath,
    data
  }) {
    const regex = new RegExp(`^${key}=.*$`, "m");
    if (data.match(regex)) {
      data = data.replace(regex, `${key}=${value}`);
    } else {
      data += `
${key}=${value}`;
    }
    await this.writeFile({ filePath, data });
    console.info(`${key} set to ${value} in ENV file.`);
    return data;
  }
  async getEnvValue(key) {
    try {
      const data = await this.readFile(this.filePath);
      const regex = new RegExp(`^${key}=(.*)$`, "m");
      const match = data.match(regex);
      return match?.[1] || null;
    } catch (err) {
      console.error(`Error reading ENV value: ${err}`);
      return null;
    }
  }
  async setEnvValue(key, value) {
    try {
      const data = await this.readFile(this.filePath);
      await this.updateEnvData({ key, value, data });
    } catch (err) {
      console.error(`Error writing ENV value: ${err}`);
    }
  }
};

// src/services/service.file.ts
var FileService = class {
  /**
   *
   * @param inputFile the file in the starter files directory to copy
   * @param outputFilePath the destination path
   * @param replaceIfExists flag to replace if it exists
   * @returns
   */
  async copyStarterFile(inputFile, outputFilePath, replaceIfExists) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const filePath = path.resolve(__dirname, "starter-files", inputFile);
    const fileString = fs3__default.readFileSync(filePath, "utf8");
    if (fs3__default.existsSync(outputFilePath) && !replaceIfExists) {
      console.info(`${outputFilePath} already exists`);
      return false;
    }
    await fsExtra.outputFile(outputFilePath, fileString);
    return true;
  }
  async setupEnvFile({ dbUrl }) {
    const envPath = path.join(process.cwd(), ".env.development");
    await fsExtra.ensureFile(envPath);
    const fileEnvService = new FileEnvService(envPath);
    await fileEnvService.setEnvValue("DB_URL", dbUrl);
  }
  getFirstExistingFile(files) {
    for (const f of files) {
      if (fs3__default.existsSync(f)) {
        return f;
      }
    }
    throw new Error("Missing required file, checked the following paths: " + files.join(", "));
  }
  replaceValuesInFile({
    filePath,
    replacements
  }) {
    let fileContent = fs3__default.readFileSync(filePath, "utf8");
    replacements.forEach(({ search, replace }) => {
      fileContent = fileContent.replaceAll(search, replace);
    });
    fs3__default.writeFileSync(filePath, fileContent);
  }
};

// src/commands/init/utils.ts
var exec = util.promisify(child_process.exec);
var LLMProvider = ["openai", "anthropic", "groq", "google", "cerebras", "mistral"];
var COMPONENTS = ["agents", "workflows", "tools", "scorers"];
function isValidLLMProvider(value) {
  return LLMProvider.includes(value);
}
function areValidComponents(values) {
  return values.every((value) => COMPONENTS.includes(value));
}
var getModelIdentifier = (llmProvider) => {
  if (llmProvider === "openai") {
    return `'openai/gpt-4o-mini'`;
  } else if (llmProvider === "anthropic") {
    return `'anthropic/claude-sonnet-4-5-20250929'`;
  } else if (llmProvider === "groq") {
    return `'groq/llama-3.3-70b-versatile'`;
  } else if (llmProvider === "google") {
    return `'google/gemini-2.5-pro'`;
  } else if (llmProvider === "cerebras") {
    return `'cerebras/llama-3.3-70b'`;
  } else if (llmProvider === "mistral") {
    return `'mistral/mistral-medium-2508'`;
  }
};
async function writeAgentSample(llmProvider, destPath, addExampleTool, addScorers) {
  const modelString = getModelIdentifier(llmProvider);
  const instructions = `
      You are a helpful weather assistant that provides accurate weather information and can help planning activities based on the weather.

      Your primary function is to help users get weather details for specific locations. When responding:
      - Always ask for a location if none is provided
      - If the location name isn't in English, please translate it
      - If giving a location with multiple parts (e.g. "New York, NY"), use the most relevant part (e.g. "New York")
      - Include relevant details like humidity, wind conditions, and precipitation
      - Keep responses concise but informative
      - If the user asks for activities and provides the weather forecast, suggest activities based on the weather forecast.
      - If the user asks for activities, respond in the format they request.

      ${addExampleTool ? "Use the weatherTool to fetch current weather data." : ""}
`;
  const content = `
import { Agent } from '@mastra/core/agent';
import { Memory } from '@mastra/memory';
import { LibSQLStore } from '@mastra/libsql';
${addExampleTool ? `import { weatherTool } from '../tools/weather-tool';` : ""}
${addScorers ? `import { scorers } from '../scorers/weather-scorer';` : ""}

export const weatherAgent = new Agent({
  name: 'Weather Agent',
  instructions: \`${instructions}\`,
  model: ${modelString},
  ${addExampleTool ? "tools: { weatherTool }," : ""}
  ${addScorers ? `scorers: {
    toolCallAppropriateness: {
      scorer: scorers.toolCallAppropriatenessScorer,
      sampling: {
        type: 'ratio',
        rate: 1,
      },
    },
    completeness: {
      scorer: scorers.completenessScorer,
      sampling: {
        type: 'ratio',
        rate: 1,
      },
    },
    translation: {
      scorer: scorers.translationScorer,
      sampling: {
        type: 'ratio',
        rate: 1,
      },
    },
  },` : ""}
  memory: new Memory({
    storage: new LibSQLStore({
      url: "file:../mastra.db", // path is relative to the .mastra/output directory
    })
  })
});
    `;
  const formattedContent = await prettier.format(content, {
    parser: "typescript",
    singleQuote: true
  });
  await fs4.writeFile(destPath, "");
  await fs4.writeFile(destPath, formattedContent);
}
async function writeWorkflowSample(destPath) {
  const content = `import { createStep, createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

const forecastSchema = z.object({
  date: z.string(),
  maxTemp: z.number(),
  minTemp: z.number(),
  precipitationChance: z.number(),
  condition: z.string(),
  location: z.string(),
})

function getWeatherCondition(code: number): string {
  const conditions: Record<number, string> = {
    0: 'Clear sky',
    1: 'Mainly clear',
    2: 'Partly cloudy',
    3: 'Overcast',
    45: 'Foggy',
    48: 'Depositing rime fog',
    51: 'Light drizzle',
    53: 'Moderate drizzle',
    55: 'Dense drizzle',
    61: 'Slight rain',
    63: 'Moderate rain',
    65: 'Heavy rain',
    71: 'Slight snow fall',
    73: 'Moderate snow fall',
    75: 'Heavy snow fall',
    95: 'Thunderstorm',
  }
  return conditions[code] || 'Unknown'
}

const fetchWeather = createStep({
  id: 'fetch-weather',
  description: 'Fetches weather forecast for a given city',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: forecastSchema,
  execute: async ({ inputData }) => {
    if (!inputData) {
      throw new Error('Input data not found');
    }

    const geocodingUrl = \`https://geocoding-api.open-meteo.com/v1/search?name=\${encodeURIComponent(inputData.city)}&count=1\`;
    const geocodingResponse = await fetch(geocodingUrl);
    const geocodingData = (await geocodingResponse.json()) as {
      results: { latitude: number; longitude: number; name: string }[];
    };

    if (!geocodingData.results?.[0]) {
      throw new Error(\`Location '\${inputData.city}' not found\`);
    }

    const { latitude, longitude, name } = geocodingData.results[0];

    const weatherUrl = \`https://api.open-meteo.com/v1/forecast?latitude=\${latitude}&longitude=\${longitude}&current=precipitation,weathercode&timezone=auto,&hourly=precipitation_probability,temperature_2m\`;
    const response = await fetch(weatherUrl);
    const data = (await response.json()) as {
      current: {
        time: string
        precipitation: number
        weathercode: number
      }
      hourly: {
        precipitation_probability: number[]
        temperature_2m: number[]
      }
    }

    const forecast = {
      date: new Date().toISOString(),
      maxTemp: Math.max(...data.hourly.temperature_2m),
      minTemp: Math.min(...data.hourly.temperature_2m),
      condition: getWeatherCondition(data.current.weathercode),
      precipitationChance: data.hourly.precipitation_probability.reduce(
        (acc, curr) => Math.max(acc, curr),
        0
      ),
      location: name
    }

    return forecast;
  },
});


const planActivities = createStep({
  id: 'plan-activities',
  description: 'Suggests activities based on weather conditions',
  inputSchema: forecastSchema,
  outputSchema: z.object({
    activities: z.string(),
  }),
  execute: async ({ inputData, mastra }) => {
    const forecast = inputData

    if (!forecast) {
      throw new Error('Forecast data not found')
    }

    const agent = mastra?.getAgent('weatherAgent');
    if (!agent) {
      throw new Error('Weather agent not found');
    }

    const prompt = \`Based on the following weather forecast for \${forecast.location}, suggest appropriate activities:
      \${JSON.stringify(forecast, null, 2)}
      For each day in the forecast, structure your response exactly as follows:

      \u{1F4C5} [Day, Month Date, Year]
      \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550

      \u{1F321}\uFE0F WEATHER SUMMARY
      \u2022 Conditions: [brief description]
      \u2022 Temperature: [X\xB0C/Y\xB0F to A\xB0C/B\xB0F]
      \u2022 Precipitation: [X% chance]

      \u{1F305} MORNING ACTIVITIES
      Outdoor:
      \u2022 [Activity Name] - [Brief description including specific location/route]
        Best timing: [specific time range]
        Note: [relevant weather consideration]

      \u{1F31E} AFTERNOON ACTIVITIES
      Outdoor:
      \u2022 [Activity Name] - [Brief description including specific location/route]
        Best timing: [specific time range]
        Note: [relevant weather consideration]

      \u{1F3E0} INDOOR ALTERNATIVES
      \u2022 [Activity Name] - [Brief description including specific venue]
        Ideal for: [weather condition that would trigger this alternative]

      \u26A0\uFE0F SPECIAL CONSIDERATIONS
      \u2022 [Any relevant weather warnings, UV index, wind conditions, etc.]

      Guidelines:
      - Suggest 2-3 time-specific outdoor activities per day
      - Include 1-2 indoor backup options
      - For precipitation >50%, lead with indoor activities
      - All activities must be specific to the location
      - Include specific venues, trails, or locations
      - Consider activity intensity based on temperature
      - Keep descriptions concise but informative

      Maintain this exact formatting for consistency, using the emoji and section headers as shown.\`;

    const response = await agent.stream([
      {
        role: 'user',
        content: prompt,
      },
    ]);

    let activitiesText = '';

    for await (const chunk of response.textStream) {
      process.stdout.write(chunk);
      activitiesText += chunk;
    }

    return {
      activities: activitiesText,
    };
  },
});

const weatherWorkflow = createWorkflow({
  id: 'weather-workflow',
  inputSchema: z.object({
    city: z.string().describe('The city to get the weather for'),
  }),
  outputSchema: z.object({
    activities: z.string(),
  })
})
  .then(fetchWeather)
  .then(planActivities);

weatherWorkflow.commit();

export { weatherWorkflow };`;
  const formattedContent = await prettier.format(content, {
    parser: "typescript",
    semi: true,
    singleQuote: true
  });
  await fs4.writeFile(destPath, formattedContent);
}
async function writeToolSample(destPath) {
  const fileService = new FileService();
  await fileService.copyStarterFile("tools.ts", destPath);
}
async function writeScorersSample(llmProvider, destPath) {
  const modelString = getModelIdentifier(llmProvider);
  const content = `import { z } from 'zod';
import { createToolCallAccuracyScorerCode } from '@mastra/evals/scorers/code';
import { createCompletenessScorer } from '@mastra/evals/scorers/code';
import { createScorer } from '@mastra/core/scores';

export const toolCallAppropriatenessScorer = createToolCallAccuracyScorerCode({
  expectedTool: 'weatherTool',
  strictMode: false,
});

export const completenessScorer = createCompletenessScorer();

// Custom LLM-judged scorer: evaluates if non-English locations are translated appropriately
export const translationScorer = createScorer({
  name: 'Translation Quality',
  description: 'Checks that non-English location names are translated and used correctly',
  type: 'agent',
  judge: {
    model: ${modelString},
    instructions:
      'You are an expert evaluator of translation quality for geographic locations. ' +
      'Determine whether the user text mentions a non-English location and whether the assistant correctly uses an English translation of that location. ' +
      'Be lenient with transliteration differences and diacritics. ' +
      'Return only the structured JSON matching the provided schema.',
  },
})
  .preprocess(({ run }) => {
    const userText = (run.input?.inputMessages?.[0]?.content as string) || '';
    const assistantText = (run.output?.[0]?.content as string) || '';
    return { userText, assistantText };
  })
  .analyze({
    description: 'Extract location names and detect language/translation adequacy',
    outputSchema: z.object({
      nonEnglish: z.boolean(),
      translated: z.boolean(),
      confidence: z.number().min(0).max(1).default(1),
      explanation: z.string().default(''),
    }),
    createPrompt: ({ results }) => \`
            You are evaluating if a weather assistant correctly handled translation of a non-English location.
            User text:
            """
            \${results.preprocessStepResult.userText}
            """
            Assistant response:
            """
            \${results.preprocessStepResult.assistantText}
            """
            Tasks:
            1) Identify if the user mentioned a location that appears non-English.
            2) If non-English, check whether the assistant used a correct English translation of that location in its response.
            3) Be lenient with transliteration differences (e.g., accents/diacritics).
            Return JSON with fields:
            {
            "nonEnglish": boolean,
            "translated": boolean,
            "confidence": number, // 0-1
            "explanation": string
            }
        \`,
  })
  .generateScore(({ results }) => {
    const r = (results as any)?.analyzeStepResult || {};
    if (!r.nonEnglish) return 1; // If not applicable, full credit
    if (r.translated) return Math.max(0, Math.min(1, 0.7 + 0.3 * (r.confidence ?? 1)));
    return 0; // Non-English but not translated
  })
  .generateReason(({ results, score }) => {
    const r = (results as any)?.analyzeStepResult || {};
    return \`Translation scoring: nonEnglish=\${r.nonEnglish ?? false}, translated=\${r.translated ?? false}, confidence=\${r.confidence ?? 0}. Score=\${score}. \${r.explanation ?? ''}\`;
  });

export const scorers = {
  toolCallAppropriatenessScorer,
  completenessScorer,
  translationScorer,
};`;
  const formattedContent = await prettier.format(content, {
    parser: "typescript",
    singleQuote: true
  });
  await fs4.writeFile(destPath, formattedContent);
}
async function writeCodeSampleForComponents(llmprovider, component, destPath, importComponents) {
  switch (component) {
    case "agents":
      return writeAgentSample(
        llmprovider,
        destPath,
        importComponents.includes("tools"),
        importComponents.includes("scorers")
      );
    case "tools":
      return writeToolSample(destPath);
    case "workflows":
      return writeWorkflowSample(destPath);
    case "scorers":
      return writeScorersSample(llmprovider, destPath);
    default:
      return "";
  }
}
var createComponentsDir = async (dirPath, component) => {
  const componentPath = dirPath + `/${component}`;
  await fsExtra.ensureDir(componentPath);
};
var writeIndexFile = async ({
  dirPath,
  addAgent,
  addExample,
  addWorkflow,
  addScorers
}) => {
  const indexPath = dirPath + "/index.ts";
  const destPath = path.join(indexPath);
  try {
    await fs4.writeFile(destPath, "");
    const filteredExports = [
      addWorkflow ? `workflows: { weatherWorkflow },` : "",
      addAgent ? `agents: { weatherAgent },` : "",
      addScorers ? `scorers: { toolCallAppropriatenessScorer, completenessScorer, translationScorer },` : ""
    ].filter(Boolean);
    if (!addExample) {
      await fs4.writeFile(
        destPath,
        `
import { Mastra } from '@mastra/core';

export const mastra = new Mastra()
        `
      );
      return;
    }
    await fs4.writeFile(
      destPath,
      `
import { Mastra } from '@mastra/core/mastra';
import { PinoLogger } from '@mastra/loggers';
import { LibSQLStore } from '@mastra/libsql';
${addWorkflow ? `import { weatherWorkflow } from './workflows/weather-workflow';` : ""}
${addAgent ? `import { weatherAgent } from './agents/weather-agent';` : ""}
${addScorers ? `import { toolCallAppropriatenessScorer, completenessScorer, translationScorer } from './scorers/weather-scorer';` : ""}

export const mastra = new Mastra({
  ${filteredExports.join("\n  ")}
  storage: new LibSQLStore({
    // stores observability, scores, ... into memory storage, if it needs to persist, change to file:../mastra.db
    url: ":memory:",
  }),
  logger: new PinoLogger({
    name: 'Mastra',
    level: 'info',
  }),
  telemetry: {
    // Telemetry is deprecated and will be removed in the Nov 4th release
    enabled: false, 
  },
  observability: {
    // Enables DefaultExporter and CloudExporter for AI tracing
    default: { enabled: true }, 
  },
});
`
    );
  } catch (err) {
    throw err;
  }
};
var checkAndInstallCoreDeps = async (addExample) => {
  const spinner4 = yoctoSpinner2({ text: "Installing Mastra core dependencies" });
  let packages = [];
  try {
    const depService = new DepsService();
    spinner4.start();
    const needsCore = await depService.checkDependencies(["@mastra/core"]) !== `ok`;
    const needsCli = await depService.checkDependencies(["mastra"]) !== `ok`;
    const needsZod = await depService.checkDependencies(["zod"]) !== `ok`;
    if (needsCore) {
      packages.push({ name: "@mastra/core", version: "latest" });
    }
    if (needsCli) {
      packages.push({ name: "mastra", version: "latest" });
    }
    if (needsZod) {
      packages.push({ name: "zod", version: "^4" });
    }
    if (addExample) {
      const needsLibsql = await depService.checkDependencies(["@mastra/libsql"]) !== `ok`;
      if (needsLibsql) {
        packages.push({ name: "@mastra/libsql", version: "latest" });
      }
    }
    if (packages.length > 0) {
      await depService.installPackages(packages.map((pkg) => `${pkg.name}@${pkg.version}`));
    }
    spinner4.success("Successfully installed Mastra core dependencies");
  } catch (err) {
    spinner4.error(`Failed to install core dependencies: ${err instanceof Error ? err.message : "Unknown error"}`);
  }
};
var getAPIKey = async (provider) => {
  let key = "OPENAI_API_KEY";
  switch (provider) {
    case "anthropic":
      key = "ANTHROPIC_API_KEY";
      return key;
    case "groq":
      key = "GROQ_API_KEY";
      return key;
    case "google":
      key = "GOOGLE_GENERATIVE_AI_API_KEY";
      return key;
    case "cerebras":
      key = "CEREBRAS_API_KEY";
      return key;
    case "mistral":
      key = "MISTRAL_API_KEY";
      return key;
    default:
      return key;
  }
};
var writeAPIKey = async ({ provider, apiKey }) => {
  const envFileName = apiKey ? ".env" : ".env.example";
  const key = await getAPIKey(provider);
  const escapedKey = shellQuote2.quote([key]);
  const escapedApiKey = shellQuote2.quote([apiKey ? apiKey : "your-api-key"]);
  await exec(`echo ${escapedKey}=${escapedApiKey} >> ${envFileName}`);
};
var createMastraDir = async (directory) => {
  let dir = directory.trim().split("/").filter((item) => item !== "");
  const dirPath = path.join(process.cwd(), ...dir, "mastra");
  try {
    await fs4.access(dirPath);
    return { ok: false };
  } catch {
    await fsExtra.ensureDir(dirPath);
    return { ok: true, dirPath };
  }
};
var writeCodeSample = async (dirPath, component, llmProvider, importComponents) => {
  const destPath = dirPath + `/${component}/weather-${component.slice(0, -1)}.ts`;
  try {
    await writeCodeSampleForComponents(llmProvider, component, destPath, importComponents);
  } catch (err) {
    throw err;
  }
};
var LLM_PROVIDERS = [
  { value: "openai", label: "OpenAI", hint: "recommended" },
  { value: "anthropic", label: "Anthropic" },
  { value: "groq", label: "Groq" },
  { value: "google", label: "Google" },
  { value: "cerebras", label: "Cerebras" },
  { value: "mistral", label: "Mistral" }
];
var interactivePrompt = async (args2 = {}) => {
  const { skip = {}, options: { showBanner = true } = {} } = args2;
  if (showBanner) {
    p.intro(color2.inverse(" Mastra Init "));
  }
  const mastraProject = await p.group(
    {
      directory: () => p.text({
        message: "Where should we create the Mastra files? (default: src/)",
        placeholder: "src/",
        defaultValue: "src/"
      }),
      llmProvider: () => skip?.llmProvider ? void 0 : p.select({
        message: "Select a default provider:",
        options: LLM_PROVIDERS
      }),
      llmApiKey: async ({ results: { llmProvider } }) => {
        if (skip?.llmApiKey) return void 0;
        const llmName = LLM_PROVIDERS.find((p6) => p6.value === llmProvider)?.label || "provider";
        const keyChoice = await p.select({
          message: `Enter your ${llmName} API key?`,
          options: [
            { value: "skip", label: "Skip for now", hint: "default" },
            { value: "enter", label: "Enter API key" }
          ],
          initialValue: "skip"
        });
        if (keyChoice === "enter") {
          return p.text({
            message: "Enter your API key:",
            placeholder: "sk-...",
            validate: (value) => {
              if (value.length === 0) return "API key cannot be empty";
            }
          });
        }
        return void 0;
      },
      configureEditorWithDocsMCP: async () => {
        const windsurfIsAlreadyInstalled = await globalMCPIsAlreadyInstalled(`windsurf`);
        const cursorIsAlreadyInstalled = await globalMCPIsAlreadyInstalled(`cursor`);
        const vscodeIsAlreadyInstalled = await globalMCPIsAlreadyInstalled(`vscode`);
        const editor = await p.select({
          message: `Make your IDE into a Mastra expert? (Installs Mastra's MCP server)`,
          options: [
            { value: "skip", label: "Skip for now", hint: "default" },
            {
              value: "cursor",
              label: "Cursor (project only)",
              hint: cursorIsAlreadyInstalled ? `Already installed globally` : void 0
            },
            {
              value: "cursor-global",
              label: "Cursor (global, all projects)",
              hint: cursorIsAlreadyInstalled ? `Already installed` : void 0
            },
            {
              value: "windsurf",
              label: "Windsurf",
              hint: windsurfIsAlreadyInstalled ? `Already installed` : void 0
            },
            {
              value: "vscode",
              label: "VSCode",
              hint: vscodeIsAlreadyInstalled ? `Already installed` : void 0
            }
          ]
        });
        if (editor === `skip`) return void 0;
        if (editor === `windsurf` && windsurfIsAlreadyInstalled) {
          p.log.message(`
Windsurf is already installed, skipping.`);
          return void 0;
        }
        if (editor === `vscode` && vscodeIsAlreadyInstalled) {
          p.log.message(`
VSCode is already installed, skipping.`);
          return void 0;
        }
        if (editor === `cursor`) {
          p.log.message(
            `
Note: you will need to go into Cursor Settings -> MCP Settings and manually enable the installed Mastra MCP server.
`
          );
        }
        if (editor === `cursor-global`) {
          const confirm = await p.select({
            message: `Global install will add/update ${cursorGlobalMCPConfigPath} and make the Mastra docs MCP server available in all your Cursor projects. Continue?`,
            options: [
              { value: "yes", label: "Yes, I understand" },
              { value: "skip", label: "No, skip for now" }
            ]
          });
          if (confirm !== `yes`) {
            return void 0;
          }
        }
        if (editor === `windsurf`) {
          const confirm = await p.select({
            message: `Windsurf only supports a global MCP config (at ${windsurfGlobalMCPConfigPath}) is it ok to add/update that global config?
This means the Mastra docs MCP server will be available in all your Windsurf projects.`,
            options: [
              { value: "yes", label: "Yes, I understand" },
              { value: "skip", label: "No, skip for now" }
            ]
          });
          if (confirm !== `yes`) {
            return void 0;
          }
        }
        return editor;
      }
    },
    {
      onCancel: () => {
        p.cancel("Operation cancelled.");
        process.exit(0);
      }
    }
  );
  return mastraProject;
};
var checkForPkgJson = async () => {
  const cwd = process.cwd();
  const pkgJsonPath = path.join(cwd, "package.json");
  try {
    await fs4.access(pkgJsonPath);
  } catch {
    p.log.error(
      'No package.json file found in the current directory. Please run "npm init -y" to create one, or run "npx create-mastra@latest" to create a new Mastra project.'
    );
    process.exit(1);
  }
};

// src/commands/utils.ts
function getPackageManager() {
  const userAgent = process.env.npm_config_user_agent || "";
  const execPath = process.env.npm_execpath || "";
  if (userAgent.includes("bun")) {
    return "bun";
  }
  if (userAgent.includes("yarn")) {
    return "yarn";
  }
  if (userAgent.includes("pnpm")) {
    return "pnpm";
  }
  if (userAgent.includes("npm")) {
    return "npm";
  }
  if (execPath.includes("bun")) {
    return "bun";
  }
  if (execPath.includes("yarn")) {
    return "yarn";
  }
  if (execPath.includes("pnpm")) {
    return "pnpm";
  }
  if (execPath.includes("npm")) {
    return "npm";
  }
  return "npm";
}
function parseMcp(value) {
  if (!isValidEditor(value)) {
    throw new InvalidArgumentError(`Choose a valid value: ${EDITOR.join(", ")}`);
  }
  return value;
}
function parseComponents(value) {
  const parsedValue = value.split(",");
  if (!areValidComponents(parsedValue)) {
    throw new InvalidArgumentError(`Choose valid components: ${COMPONENTS.join(", ")}`);
  }
  return parsedValue;
}
function parseLlmProvider(value) {
  if (!isValidLLMProvider(value)) {
    throw new InvalidArgumentError(`Choose a valid provider: ${LLMProvider.join(", ")}`);
  }
  return value;
}
function shouldSkipDotenvLoading() {
  return process.env.MASTRA_SKIP_DOTENV === "true" || process.env.MASTRA_SKIP_DOTENV === "1";
}
var logger = createLogger(false);
function createLogger(debug = false) {
  return new PinoLogger({
    name: "Mastra CLI",
    level: debug ? "debug" : "info"
  });
}

// src/utils/clone-template.ts
var exec2 = util.promisify(child_process.exec);
async function cloneTemplate(options) {
  const { template, projectName, targetDir } = options;
  const projectPath = targetDir ? path.resolve(targetDir, projectName) : path.resolve(projectName);
  const spinner4 = yoctoSpinner2({ text: `Cloning template "${template.title}"...` }).start();
  try {
    if (await directoryExists(projectPath)) {
      spinner4.error(`Directory ${projectName} already exists`);
      throw new Error(`Directory ${projectName} already exists`);
    }
    await cloneRepositoryWithoutGit(template.githubUrl, projectPath);
    await updatePackageJson(projectPath, projectName);
    const envExamplePath = path.join(projectPath, ".env.example");
    if (await fileExists(envExamplePath)) {
      await fs4.copyFile(envExamplePath, path.join(projectPath, ".env"));
    }
    spinner4.success(`Template "${template.title}" cloned successfully to ${projectName}`);
    return projectPath;
  } catch (error) {
    spinner4.error(`Failed to clone template: ${error instanceof Error ? error.message : "Unknown error"}`);
    throw error;
  }
}
async function directoryExists(dirPath) {
  try {
    const stat = await fs4.stat(dirPath);
    return stat.isDirectory();
  } catch {
    return false;
  }
}
async function fileExists(filePath) {
  try {
    const stat = await fs4.stat(filePath);
    return stat.isFile();
  } catch {
    return false;
  }
}
async function cloneRepositoryWithoutGit(repoUrl, targetPath) {
  await fs4.mkdir(targetPath, { recursive: true });
  try {
    const degitRepo = repoUrl.replace("https://github.com/", "");
    const degitCommand = shellQuote2.quote(["npx", "degit", degitRepo, targetPath]);
    await exec2(degitCommand, {
      cwd: process.cwd()
    });
  } catch {
    try {
      const gitCommand = shellQuote2.quote(["git", "clone", repoUrl, targetPath]);
      await exec2(gitCommand, {
        cwd: process.cwd()
      });
      const gitDir = path.join(targetPath, ".git");
      if (await directoryExists(gitDir)) {
        await fs4.rm(gitDir, { recursive: true, force: true });
      }
    } catch (gitError) {
      throw new Error(`Failed to clone repository: ${gitError instanceof Error ? gitError.message : "Unknown error"}`);
    }
  }
}
async function updatePackageJson(projectPath, projectName) {
  const packageJsonPath = path.join(projectPath, "package.json");
  try {
    const packageJsonContent = await fs4.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    packageJson.name = projectName;
    await fs4.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
  } catch (error) {
    logger.warn(`Could not update package.json: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function installDependencies(projectPath, packageManager) {
  const spinner4 = yoctoSpinner2({ text: "Installing dependencies..." }).start();
  try {
    const pm = packageManager || getPackageManager();
    const installCommand = shellQuote2.quote([pm, "install"]);
    await exec2(installCommand, {
      cwd: projectPath
    });
    spinner4.success("Dependencies installed successfully");
  } catch (error) {
    spinner4.error(`Failed to install dependencies: ${error instanceof Error ? error.message : "Unknown error"}`);
    throw error;
  }
}
var TEMPLATES_API_URL = process.env.MASTRA_TEMPLATES_API_URL || "https://mastra.ai/api/templates.json";
async function loadTemplates() {
  try {
    const response = await fetch(TEMPLATES_API_URL);
    if (!response.ok) {
      throw new Error(`Failed to fetch templates: ${response.statusText}`);
    }
    const templates = await response.json();
    return templates;
  } catch (error) {
    console.error("Error loading templates:", error);
    throw new Error("Failed to load templates. Please check your internet connection and try again.");
  }
}
function pluralize(count, singular, plural) {
  return count === 1 ? singular : plural || `${singular}s`;
}
async function selectTemplate(templates) {
  const choices = templates.map((template) => {
    const parts = [];
    if (template.agents?.length) {
      parts.push(`${template.agents.length} ${pluralize(template.agents.length, "agent")}`);
    }
    if (template.tools?.length) {
      parts.push(`${template.tools.length} ${pluralize(template.tools.length, "tool")}`);
    }
    if (template.workflows?.length) {
      parts.push(`${template.workflows.length} ${pluralize(template.workflows.length, "workflow")}`);
    }
    if (template.mcp?.length) {
      parts.push(`${template.mcp.length} ${pluralize(template.mcp.length, "MCP server")}`);
    }
    if (template.networks?.length) {
      parts.push(`${template.networks.length} ${pluralize(template.networks.length, "agent network")}`);
    }
    return {
      value: template,
      label: template.title,
      hint: parts.join(", ") || "Template components"
    };
  });
  const selected = await p.select({
    message: "Select a template:",
    options: choices
  });
  if (p.isCancel(selected)) {
    return null;
  }
  return selected;
}
function findTemplateByName(templates, templateName) {
  let template = templates.find((t) => t.slug === templateName);
  if (template) return template;
  const slugWithPrefix = `template-${templateName}`;
  template = templates.find((t) => t.slug === slugWithPrefix);
  if (template) return template;
  template = templates.find((t) => t.title.toLowerCase() === templateName.toLowerCase());
  if (template) return template;
  return null;
}
function getDefaultProjectName(template) {
  return template.slug.replace(/^template-/, "");
}
var s = p.spinner();
var init = async ({
  directory = "src/",
  components,
  llmProvider = "openai",
  llmApiKey,
  addExample = false,
  configureEditorWithDocsMCP
}) => {
  s.start("Initializing Mastra");
  try {
    const result = await createMastraDir(directory);
    if (!result.ok) {
      s.stop(color2.inverse(" Mastra already initialized "));
      return { success: false };
    }
    const dirPath = result.dirPath;
    await Promise.all([
      writeIndexFile({
        dirPath,
        addExample,
        addWorkflow: components.includes("workflows"),
        addAgent: components.includes("agents"),
        addScorers: components.includes("scorers")
      }),
      ...components.map((component) => createComponentsDir(dirPath, component)),
      writeAPIKey({ provider: llmProvider, apiKey: llmApiKey })
    ]);
    if (addExample) {
      await Promise.all([
        ...components.map(
          (component) => writeCodeSample(dirPath, component, llmProvider, components)
        )
      ]);
      const depService = new DepsService();
      const needsLibsql = await depService.checkDependencies(["@mastra/libsql"]) !== `ok`;
      if (needsLibsql) {
        await depService.installPackages(["@mastra/libsql"]);
      }
      const needsMemory = components.includes(`agents`) && await depService.checkDependencies(["@mastra/memory"]) !== `ok`;
      if (needsMemory) {
        await depService.installPackages(["@mastra/memory"]);
      }
      const needsLoggers = await depService.checkDependencies(["@mastra/loggers"]) !== `ok`;
      if (needsLoggers) {
        await depService.installPackages(["@mastra/loggers"]);
      }
      const needsEvals = components.includes(`scorers`) && await depService.checkDependencies(["@mastra/evals"]) !== `ok`;
      if (needsEvals) {
        await depService.installPackages(["@mastra/evals"]);
      }
    }
    const key = await getAPIKey(llmProvider || "openai");
    if (configureEditorWithDocsMCP) {
      await installMastraDocsMCPServer({
        editor: configureEditorWithDocsMCP,
        directory: process.cwd()
      });
    }
    s.stop();
    if (!llmApiKey) {
      p.note(`
      ${color2.green("Mastra initialized successfully!")}

      Add your ${color2.cyan(key)} as an environment variable
      in your ${color2.cyan(".env")} file
      `);
    } else {
      p.note(`
      ${color2.green("Mastra initialized successfully!")}
      `);
    }
    return { success: true };
  } catch (err) {
    s.stop(color2.inverse("An error occurred while initializing Mastra"));
    console.error(err);
    return { success: false };
  }
};
var exec3 = util.promisify(child_process.exec);
var execWithTimeout = async (command, timeoutMs) => {
  try {
    const promise = exec3(command, { killSignal: "SIGTERM" });
    if (!timeoutMs) {
      return await promise;
    }
    let timeoutId;
    const timeout = new Promise((_, reject) => {
      timeoutId = setTimeout(() => reject(new Error("Command timed out")), timeoutMs);
    });
    try {
      const result = await Promise.race([promise, timeout]);
      clearTimeout(timeoutId);
      return result;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.message === "Command timed out") {
        throw new Error("Something went wrong during installation, please try again.");
      }
      throw error;
    }
  } catch (error) {
    throw error;
  }
};
async function getInitCommand(pm) {
  switch (pm) {
    case "npm":
      return "npm init -y";
    case "pnpm":
      return "pnpm init";
    case "yarn":
      return "yarn init -y";
    case "bun":
      return "bun init -y";
    default:
      return "npm init -y";
  }
}
async function initializePackageJson(pm) {
  const initCommand = await getInitCommand(pm);
  await exec3(initCommand);
  const packageJsonPath = path.join(process.cwd(), "package.json");
  const packageJson = JSON.parse(await fs4.readFile(packageJsonPath, "utf-8"));
  packageJson.type = "module";
  packageJson.engines = {
    ...packageJson.engines,
    node: ">=22.13.0"
  };
  await fs4.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
}
async function installMastraDependency(pm, dependency, versionTag, isDev, timeout) {
  let installCommand = getPackageManagerAddCommand(pm);
  if (isDev) {
    installCommand = `${installCommand} -D`;
  }
  try {
    await execWithTimeout(`${pm} ${installCommand} ${dependency}${versionTag}`, timeout);
  } catch (err) {
    if (versionTag === "@latest") {
      throw new Error(
        `Failed to install ${dependency}@latest: ${err instanceof Error ? err.message : "Unknown error"}`
      );
    }
    try {
      await execWithTimeout(`${pm} ${installCommand} ${dependency}@latest`, timeout);
    } catch (fallbackErr) {
      throw new Error(
        `Failed to install ${dependency} (tried ${versionTag} and @latest): ${fallbackErr instanceof Error ? fallbackErr.message : "Unknown error"}`
      );
    }
  }
}
var createMastraProject = async ({
  projectName: name,
  createVersionTag,
  timeout,
  llmProvider,
  llmApiKey,
  needsInteractive
}) => {
  p.intro(color2.inverse(" Mastra Create "));
  const projectName = name ?? await p.text({
    message: "What do you want to name your project?",
    placeholder: "my-mastra-app",
    defaultValue: "my-mastra-app",
    validate: (value) => {
      if (value.length === 0) return "Project name cannot be empty";
      if (fs3__default.existsSync(value)) {
        return `A directory named "${value}" already exists. Please choose a different name.`;
      }
    }
  });
  if (p.isCancel(projectName)) {
    p.cancel("Operation cancelled");
    process.exit(0);
  }
  let result;
  if (needsInteractive) {
    result = await interactivePrompt({
      options: { showBanner: false },
      skip: { llmProvider: llmProvider !== void 0, llmApiKey: llmApiKey !== void 0 }
    });
  }
  const s2 = p.spinner();
  const originalCwd = process.cwd();
  let projectPath = null;
  try {
    s2.start("Creating project");
    try {
      await fs4.mkdir(projectName);
      projectPath = path.resolve(originalCwd, projectName);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "EEXIST") {
        s2.stop(`A directory named "${projectName}" already exists. Please choose a different name.`);
        process.exit(1);
      }
      throw new Error(
        `Failed to create project directory: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
    process.chdir(projectName);
    const pm = getPackageManager();
    const installCommand = getPackageManagerAddCommand(pm);
    s2.message("Initializing project structure");
    try {
      await initializePackageJson(pm);
      const depsService = new DepsService();
      await depsService.addScriptsToPackageJson({
        dev: "mastra dev",
        build: "mastra build",
        start: "mastra start"
      });
    } catch (error) {
      throw new Error(
        `Failed to initialize project structure: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
    s2.stop("Project structure created");
    s2.start(`Installing ${pm} dependencies`);
    try {
      await exec3(`${pm} ${installCommand} zod@^4`);
      await exec3(`${pm} ${installCommand} typescript @types/node --save-dev`);
      await exec3(`echo '{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "outDir": "dist"
  },
  "include": [
    "src/**/*"
  ]
}' > tsconfig.json`);
    } catch (error) {
      throw new Error(
        `Failed to install basic dependencies: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
    s2.stop(`${pm} dependencies installed`);
    s2.start("Installing Mastra CLI");
    const versionTag = createVersionTag ? `@${createVersionTag}` : "@latest";
    try {
      await installMastraDependency(pm, "mastra", versionTag, true, timeout);
    } catch (error) {
      throw new Error(`Failed to install Mastra CLI: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    s2.stop("Mastra CLI installed");
    s2.start("Installing Mastra dependencies");
    try {
      await installMastraDependency(pm, "@mastra/core", versionTag, false, timeout);
      await installMastraDependency(pm, "@mastra/libsql", versionTag, false, timeout);
      await installMastraDependency(pm, "@mastra/memory", versionTag, false, timeout);
    } catch (error) {
      throw new Error(
        `Failed to install Mastra dependencies: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
    s2.stop("Mastra dependencies installed");
    s2.start("Adding .gitignore");
    try {
      await exec3(`echo output.txt >> .gitignore`);
      await exec3(`echo node_modules >> .gitignore`);
      await exec3(`echo dist >> .gitignore`);
      await exec3(`echo .mastra >> .gitignore`);
      await exec3(`echo .env.development >> .gitignore`);
      await exec3(`echo .env >> .gitignore`);
      await exec3(`echo *.db >> .gitignore`);
      await exec3(`echo *.db-* >> .gitignore`);
    } catch (error) {
      throw new Error(`Failed to create .gitignore: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    s2.stop(".gitignore added");
    p.outro("Project created successfully");
    console.info("");
    return { projectName, result };
  } catch (error) {
    s2.stop();
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred";
    p.cancel(`Project creation failed: ${errorMessage}`);
    if (projectPath && fs3__default.existsSync(projectPath)) {
      try {
        process.chdir(originalCwd);
        await fs4.rm(projectPath, { recursive: true, force: true });
      } catch (cleanupError) {
        console.error(
          `Warning: Failed to clean up project directory: ${cleanupError instanceof Error ? cleanupError.message : "Unknown error"}`
        );
      }
    }
    process.exit(1);
  }
};

// src/commands/create/create.ts
var create = async (args2) => {
  if (args2.template !== void 0) {
    await createFromTemplate({ ...args2, injectedAnalytics: args2.analytics });
    return;
  }
  const needsInteractive = args2.components === void 0 || args2.llmProvider === void 0 || args2.addExample === void 0;
  const { projectName, result } = await createMastraProject({
    projectName: args2?.projectName,
    createVersionTag: args2?.createVersionTag,
    timeout: args2?.timeout,
    llmProvider: args2?.llmProvider,
    llmApiKey: args2?.llmApiKey,
    needsInteractive
  });
  const directory = args2.directory || "src/";
  if (needsInteractive && result) {
    const analytics2 = getAnalytics();
    if (analytics2 && result?.llmProvider) {
      analytics2.trackEvent("cli_model_provider_selected", {
        provider: result.llmProvider,
        selection_method: "interactive"
      });
    }
    await init({
      ...result,
      llmApiKey: result?.llmApiKey,
      components: ["agents", "tools", "workflows", "scorers"],
      addExample: true
    });
    postCreate({ projectName });
    return;
  }
  const { components = [], llmProvider = "openai", addExample = false, llmApiKey } = args2;
  const analytics = getAnalytics();
  if (analytics) {
    analytics.trackEvent("cli_model_provider_selected", {
      provider: llmProvider,
      selection_method: "cli_args"
    });
  }
  await init({
    directory,
    components,
    llmProvider,
    addExample,
    llmApiKey,
    configureEditorWithDocsMCP: args2.mcpServer
  });
  postCreate({ projectName });
};
var postCreate = ({ projectName }) => {
  const packageManager = getPackageManager();
  p.outro(`
   ${color2.green("To start your project:")}

    ${color2.cyan("cd")} ${projectName}
    ${color2.cyan(`${packageManager} run dev`)}
  `);
};
function isGitHubUrl(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.hostname === "github.com" && parsedUrl.pathname.split("/").length >= 3;
  } catch {
    return false;
  }
}
async function validateGitHubProject(githubUrl) {
  const errors = [];
  try {
    const urlParts = new URL(githubUrl).pathname.split("/").filter(Boolean);
    const owner = urlParts[0];
    const repo = urlParts[1]?.replace(".git", "");
    if (!owner || !repo) {
      throw new Error("Invalid GitHub URL format");
    }
    const branches = ["main", "master"];
    let packageJsonContent = null;
    let indexContent = null;
    for (const branch of branches) {
      try {
        const packageJsonUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/package.json`;
        const packageJsonResponse = await fetch(packageJsonUrl);
        if (packageJsonResponse.ok) {
          packageJsonContent = await packageJsonResponse.text();
          const indexUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/src/mastra/index.ts`;
          const indexResponse = await fetch(indexUrl);
          if (indexResponse.ok) {
            indexContent = await indexResponse.text();
          }
          break;
        }
      } catch {
      }
    }
    if (!packageJsonContent) {
      errors.push("Could not fetch package.json from repository");
      return { isValid: false, errors };
    }
    try {
      const packageJson = JSON.parse(packageJsonContent);
      const hasMastraCore = packageJson.dependencies?.["@mastra/core"] || packageJson.devDependencies?.["@mastra/core"] || packageJson.peerDependencies?.["@mastra/core"];
      if (!hasMastraCore) {
        errors.push("Missing @mastra/core dependency in package.json");
      }
    } catch {
      errors.push("Invalid package.json format");
    }
    if (!indexContent) {
      errors.push("Missing src/mastra/index.ts file");
    } else {
      const hasMastraExport = indexContent.includes("export") && (indexContent.includes("new Mastra") || indexContent.includes("Mastra("));
      if (!hasMastraExport) {
        errors.push("src/mastra/index.ts does not export a Mastra instance");
      }
    }
    return { isValid: errors.length === 0, errors };
  } catch (error) {
    errors.push(`Failed to validate GitHub repository: ${error instanceof Error ? error.message : "Unknown error"}`);
    return { isValid: false, errors };
  }
}
async function createFromGitHubUrl(url) {
  const urlParts = new URL(url).pathname.split("/").filter(Boolean);
  const owner = urlParts[0] || "unknown";
  const repo = urlParts[1] || "unknown";
  return {
    githubUrl: url,
    title: `${owner}/${repo}`,
    slug: repo,
    agents: [],
    mcp: [],
    tools: [],
    networks: [],
    workflows: []
  };
}
async function createFromTemplate(args2) {
  let selectedTemplate;
  if (args2.template === true) {
    const templates = await loadTemplates();
    const selected = await selectTemplate(templates);
    if (!selected) {
      p.log.info("No template selected. Exiting.");
      return;
    }
    selectedTemplate = selected;
  } else if (args2.template && typeof args2.template === "string") {
    if (isGitHubUrl(args2.template)) {
      const spinner4 = p.spinner();
      spinner4.start("Validating GitHub repository...");
      const validation = await validateGitHubProject(args2.template);
      if (!validation.isValid) {
        spinner4.stop("Validation failed");
        p.log.error("This does not appear to be a valid Mastra project:");
        validation.errors.forEach((error) => p.log.error(`  - ${error}`));
        throw new Error("Invalid Mastra project");
      }
      spinner4.stop("Valid Mastra project \u2713");
      selectedTemplate = await createFromGitHubUrl(args2.template);
    } else {
      const templates = await loadTemplates();
      const found = findTemplateByName(templates, args2.template);
      if (!found) {
        p.log.error(`Template "${args2.template}" not found. Available templates:`);
        templates.forEach((t) => p.log.info(`  - ${t.title} (use: ${t.slug.replace("template-", "")})`));
        throw new Error(`Template "${args2.template}" not found`);
      }
      selectedTemplate = found;
    }
  }
  if (!selectedTemplate) {
    throw new Error("No template selected");
  }
  let projectName = args2.projectName;
  if (!projectName) {
    const defaultName = getDefaultProjectName(selectedTemplate);
    const response = await p.text({
      message: "What is your project name?",
      defaultValue: defaultName,
      placeholder: defaultName
    });
    if (p.isCancel(response)) {
      p.log.info("Project creation cancelled.");
      return;
    }
    projectName = response;
  }
  let projectPath = null;
  try {
    const analytics = args2.injectedAnalytics || getAnalytics();
    if (analytics) {
      analytics.trackEvent("cli_template_used", {
        template_slug: selectedTemplate.slug,
        template_title: selectedTemplate.title
      });
    }
    projectPath = await cloneTemplate({
      template: selectedTemplate,
      projectName
    });
    await installDependencies(projectPath);
    p.note(`
      ${color2.green("Mastra template installed!")}

      Add the necessary environment
      variables in your ${color2.cyan(".env")} file
      `);
    postCreate({ projectName });
  } catch (error) {
    if (projectPath) {
      try {
        if (fs3__default.existsSync(projectPath)) {
          await fs4.rm(projectPath, { recursive: true, force: true });
        }
      } catch (cleanupError) {
        console.error(
          `Warning: Failed to clean up project directory: ${cleanupError instanceof Error ? cleanupError.message : "Unknown error"}`
        );
      }
    }
    p.log.error(`Failed to create project from template: ${error instanceof Error ? error.message : "Unknown error"}`);
    throw error;
  }
}

export { COMPONENTS, DepsService, FileService, LLMProvider, checkAndInstallCoreDeps, checkForPkgJson, create, createLogger, init, interactivePrompt, logger, parseComponents, parseLlmProvider, parseMcp, shouldSkipDotenvLoading };
//# sourceMappingURL=chunk-H53A6HJD.js.map
//# sourceMappingURL=chunk-H53A6HJD.js.map