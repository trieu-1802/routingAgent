import { slash, isDependencyPartOfPackage, getPackageRootPath, getPackageName, getCompiledDepCachePath, rollupSafeName } from './chunk-NEGQTTJS.js';
import * as babel from '@babel/core';
import babel__default from '@babel/core';
import fs, { existsSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import * as path2 from 'path';
import path2__default, { dirname, join, normalize, basename as basename$1 } from 'path';
import { spawn as spawn$1 } from 'child_process';
import { rollup } from 'rollup';
import originalEsbuild from 'rollup-plugin-esbuild';
import commonjs from '@rollup/plugin-commonjs';
import resolveFrom2 from 'resolve-from';
import stripJsonComments from 'strip-json-comments';
import { createHandler } from 'typescript-paths';
import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';
import json from '@rollup/plugin-json';
import * as pkg from 'empathic/package';
import { createWorkspacesCache, findWorkspaces, findWorkspacesRoot } from 'find-workspaces';
import { noopLogger } from '@mastra/core/logger';
import virtual from '@rollup/plugin-virtual';
import { fileURLToPath, pathToFileURL } from 'url';
import { builtinModules } from 'module';
import nodeResolve from '@rollup/plugin-node-resolve';
import originalEsmShim from '@rollup/plugin-esm-shim';
import { basename } from 'path/posix';
import * as resolve from 'resolve.exports';
import { getPackageInfo } from 'local-pkg';
import { MastraBaseError, ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';

var ValidationError = class extends Error {
  type;
  stack;
  constructor(args) {
    super(args.message);
    this.type = args.type;
    this.stack = args.stack;
  }
};
function spawn(command, args = [], options = {}) {
  return new Promise((resolve2, reject) => {
    let validationError = null;
    const childProcess = spawn$1(command, args, {
      // stdio: 'inherit',
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    let stderr = "";
    childProcess.stderr?.on("data", (message) => {
      try {
        validationError = JSON.parse(message.toString());
      } catch {
        stderr += message;
      }
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve2();
      } else {
        if (validationError) {
          reject(new ValidationError(validationError));
        } else {
          reject(new Error(stderr));
        }
      }
    });
  });
}
function validate(file, { injectESMShim = false, moduleResolveMapLocation }) {
  let prefixCode = "";
  if (injectESMShim) {
    prefixCode = `import { fileURLToPath } from 'url';
import { dirname } from 'path';

globalThis.__filename = fileURLToPath(import.meta.url);
globalThis.__dirname = dirname(__filename);
    `;
  }
  function errorHandler(err) {
    console.error(
      JSON.stringify({
        type: err.name,
        message: err.message,
        stack: err.stack
      })
    );
    process.exit(1);
  }
  return spawn(
    process.execPath,
    [
      "--import",
      import.meta.resolve("@mastra/deployer/loader"),
      "--input-type=module",
      "--enable-source-maps",
      "-e",
      `${prefixCode};import('file://${slash(file)}').catch(err => {
        ${errorHandler.toString()}
        errorHandler(err);
      })`.replaceAll(/\n/g, "")
    ],
    {
      env: {
        ...process.env,
        MODULE_MAP: `${moduleResolveMapLocation}`
      },
      cwd: dirname(file)
    }
  );
}
function removeAllOptionsFromMastraExcept(result, option, logger) {
  const t = babel__default.types;
  return {
    name: "remove-all-except-" + option + "-config",
    visitor: {
      ExportNamedDeclaration: {
        // remove all exports
        exit(path3) {
          path3.remove();
        }
      },
      NewExpression(path3, state) {
        const varDeclaratorPath = path3.findParent((path4) => t.isVariableDeclarator(path4.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path3.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        let mastraArgs = t.objectExpression([]);
        if (t.isObjectExpression(path3.node.arguments[0])) {
          mastraArgs = path3.node.arguments[0];
        }
        let telemetry = mastraArgs.properties.find(
          // @ts-ignore
          (prop) => prop.key.name === option
        );
        let telemetryValue = t.objectExpression([]);
        const programPath = path3.scope.getProgramParent().path;
        if (!programPath) {
          return;
        }
        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {
          result.hasCustomConfig = true;
          telemetryValue = telemetry.value;
          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {
            const telemetryBinding = state.file.scope.getBinding(option);
            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {
              const id = path3.scope.generateUidIdentifier(option);
              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init));
              telemetryValue = id;
            }
          }
        }
        const exportDeclaration = t.exportNamedDeclaration(
          t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), telemetryValue)]),
          []
        );
        programPath.node.body.push(exportDeclaration);
      },
      Program: {
        exit(path3) {
          const hasExport = path3.node.body.some(
            (node) => node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration"
          );
          if (!hasExport) {
            if (logger) {
              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:
export const mastra = new Mastra({
  ${option}: <value>
})

`);
            }
            const fallbackExportDeclaration = t.exportNamedDeclaration(
              t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),
              []
            );
            path3.node.body.push(fallbackExportDeclaration);
          }
        }
      }
    }
  };
}

// src/build/babel/remove-all-options-bundler.ts
function removeAllOptionsExceptBundler(result, logger) {
  return removeAllOptionsFromMastraExcept(result, "bundler", logger);
}
function esbuild(options = {}) {
  return originalEsbuild({
    target: "node20",
    platform: "node",
    minify: false,
    ...options
  });
}
var PLUGIN_NAME = "tsconfig-paths";
function hasPaths(tsConfigPath) {
  try {
    const content = fs.readFileSync(tsConfigPath, "utf8");
    const config = JSON.parse(stripJsonComments(content));
    return !!(config.compilerOptions?.paths && Object.keys(config.compilerOptions.paths).length > 0);
  } catch {
    return false;
  }
}
function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve } = {}) {
  const handlerCache = /* @__PURE__ */ new Map();
  function findTsConfigForFile(filePath) {
    let currentDir = path2__default.dirname(filePath);
    const root = path2__default.parse(currentDir).root;
    while (currentDir !== root) {
      const tsConfigPath2 = path2__default.join(currentDir, "tsconfig.json");
      if (fs.existsSync(tsConfigPath2)) {
        if (hasPaths(tsConfigPath2)) {
          return tsConfigPath2;
        }
      }
      const tsConfigBasePath = path2__default.join(currentDir, "tsconfig.base.json");
      if (fs.existsSync(tsConfigBasePath)) {
        if (hasPaths(tsConfigBasePath)) {
          return tsConfigBasePath;
        }
      }
      currentDir = path2__default.dirname(currentDir);
    }
    return null;
  }
  function getHandlerForFile(filePath) {
    if (tsConfigPath && typeof tsConfigPath === "string") {
      if (!handlerCache.has(tsConfigPath)) {
        handlerCache.set(
          tsConfigPath,
          createHandler({
            log: () => {
            },
            tsConfigPath,
            respectCoreModule,
            falllback: (moduleName) => fs.existsSync(moduleName)
          })
        );
      }
      return handlerCache.get(tsConfigPath);
    }
    const configPath = findTsConfigForFile(filePath);
    if (!configPath) {
      return null;
    }
    if (!handlerCache.has(configPath)) {
      handlerCache.set(
        configPath,
        createHandler({
          log: () => {
          },
          tsConfigPath: configPath,
          respectCoreModule,
          falllback: (moduleName) => fs.existsSync(moduleName)
        })
      );
    }
    return handlerCache.get(configPath);
  }
  function resolveAlias(request, importer) {
    const dynamicHandler = getHandlerForFile(importer);
    if (!dynamicHandler) {
      return null;
    }
    const resolved = dynamicHandler(request, normalize(importer));
    return resolved;
  }
  return {
    name: PLUGIN_NAME,
    async resolveId(request, importer, options) {
      if (!importer || request.startsWith("\0") || importer.charCodeAt(0) === 0) {
        return null;
      }
      const moduleName = resolveAlias(request, importer);
      if (!moduleName) {
        let importerMeta = {};
        const resolved2 = await this.resolve(request, importer, { skipSelf: true, ...options });
        if (!resolved2) {
          return null;
        }
        if (localResolve) {
          const importerInfo = this.getModuleInfo(importer);
          importerMeta = importerInfo?.meta || {};
          if (!request.startsWith("./") && !request.startsWith("../") && importerMeta?.[PLUGIN_NAME]?.resolved) {
            return {
              ...resolved2,
              external: !request.startsWith("hono/") && request !== "hono"
            };
          }
        }
        return {
          ...resolved2,
          meta: {
            ...resolved2.meta || {},
            ...importerMeta
          }
        };
      }
      if (!path2__default.extname(moduleName)) {
        const resolved2 = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
        if (!resolved2) {
          return null;
        }
        return {
          ...resolved2,
          meta: {
            ...resolved2.meta,
            [PLUGIN_NAME]: {
              resolved: true
            }
          }
        };
      }
      const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
      if (!resolved) {
        return null;
      }
      return {
        ...resolved,
        meta: {
          ...resolved.meta,
          [PLUGIN_NAME]: {
            resolved: true
          }
        }
      };
    }
  };
}
function removeNonReferencedNodes() {
  const t = babel__default.types;
  return {
    name: "remove-non-referenced-nodes",
    visitor: {
      Program(path3) {
        const scope = path3.scope;
        const currentBody = path3.get("body");
        const filteredBody = currentBody.filter((childPath) => {
          if (childPath.isExportDeclaration()) {
            return true;
          }
          if (childPath.isVariableDeclaration()) {
            return childPath.node.declarations.some((decl) => {
              if (!t.isIdentifier(decl.id)) {
                return false;
              }
              const name = decl.id.name;
              const binding = scope.getBinding(name);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {
            if (!t.isIdentifier(childPath.node.id)) {
              return false;
            }
            const name = childPath.node.id.name;
            const binding = scope.getBinding(name);
            return binding && (binding.referenced || binding.referencePaths.length > 0);
          }
          if (childPath.isImportDeclaration()) {
            return childPath.node.specifiers.some((specifier) => {
              const importedName = specifier.local.name;
              const binding = scope.getBinding(importedName);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          return false;
        });
        path3.set(
          "body",
          filteredBody.map((p) => p.node)
        );
      }
    }
  };
}

// src/build/plugins/remove-unused-references.ts
function recursiveRemoveNonReferencedNodes(code) {
  return new Promise(async (resolve2, reject) => {
    babel.transform(
      code,
      {
        babelrc: false,
        configFile: false,
        plugins: [removeNonReferencedNodes()]
      },
      (err, result) => {
        if (err) {
          return reject(err);
        }
        if (result && result.code !== code) {
          return recursiveRemoveNonReferencedNodes(result.code).then(resolve2, reject);
        }
        resolve2({
          code: result.code,
          map: result.map
        });
      }
    );
  });
}
function extractMastraOptionBundler(name, entryFile, transformer, result, logger) {
  return rollup({
    logLevel: "silent",
    input: {
      [`${name}-config`]: entryFile
    },
    treeshake: "smallest",
    plugins: [
      tsConfigPaths(),
      // transpile typescript to something we understand
      esbuild(),
      optimizeLodashImports({
        include: "**/*.{js,ts,mjs,cjs}"
      }),
      commonjs({
        extensions: [".js", ".ts"],
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      json(),
      {
        name: `extract-${name}-config`,
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return new Promise((resolve2, reject) => {
            babel.transform(
              code,
              {
                babelrc: false,
                configFile: false,
                filename: id,
                plugins: [transformer(result, logger)]
              },
              (err, result2) => {
                if (err) {
                  return reject(err);
                }
                resolve2({
                  code: result2.code,
                  map: result2.map
                });
              }
            );
          });
        }
      },
      // let esbuild remove all unused imports
      esbuild(),
      {
        name: "cleanup",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return recursiveRemoveNonReferencedNodes(code);
        }
      },
      // let esbuild remove it once more
      esbuild()
    ]
  });
}
async function extractMastraOption(name, entryFile, transformer, outputDir, logger) {
  const result = {
    hasCustomConfig: false
  };
  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);
  const output = await bundler.write({
    dir: outputDir,
    format: "es",
    entryFileNames: "[name].mjs"
  });
  if (result.hasCustomConfig) {
    const configPath = `${outputDir}/${name}-config.mjs`;
    return {
      bundleOutput: output,
      getConfig: () => import(`file:${configPath}`).then((m) => m[name])
    };
  }
  return null;
}

// src/build/bundlerOptions.ts
async function getBundlerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption(
    "bundler",
    entryFile,
    removeAllOptionsExceptBundler,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}
function checkConfigExport(result) {
  const t = babel__default.types;
  const mastraVars = /* @__PURE__ */ new Set();
  return {
    visitor: {
      ExportNamedDeclaration(path3) {
        const decl = path3.node.declaration;
        if (t.isVariableDeclaration(decl)) {
          const varDecl = decl.declarations[0];
          if (t.isIdentifier(varDecl?.id, { name: "mastra" }) && t.isNewExpression(varDecl.init) && t.isIdentifier(varDecl.init.callee, { name: "Mastra" })) {
            result.hasValidConfig = true;
          }
        }
        if (Array.isArray(path3.node.specifiers)) {
          for (const spec of path3.node.specifiers) {
            if (t.isExportSpecifier(spec) && t.isIdentifier(spec.exported, { name: "mastra" }) && t.isIdentifier(spec.local) && mastraVars.has(spec.local.name)) {
              result.hasValidConfig = true;
            }
          }
        }
      },
      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`
      VariableDeclaration(path3) {
        for (const decl of path3.node.declarations) {
          if (t.isIdentifier(decl.id) && t.isNewExpression(decl.init) && t.isIdentifier(decl.init.callee, { name: "Mastra" })) {
            mastraVars.add(decl.id.name);
          }
        }
      }
    }
  };
}
var workspacesCache = createWorkspacesCache();
async function getWorkspaceInformation({
  dir = process.cwd(),
  mastraEntryFile
}) {
  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });
  const location = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());
  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });
  const _workspaceMap = new Map(
    workspaces?.map((workspace) => [
      workspace.package.name,
      {
        location: workspace.location,
        dependencies: workspace.package.dependencies,
        version: workspace.package.version
      }
    ]) ?? []
  );
  const isWorkspacePackage = (workspaces ?? []).some((ws) => ws.location === location);
  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : void 0;
  return {
    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages
    workspaceMap: isWorkspacePackage ? _workspaceMap : /* @__PURE__ */ new Map(),
    workspaceRoot,
    isWorkspacePackage
  };
}
function isNodeBuiltin(dep) {
  const [pkg2] = dep.split("/");
  return dep.startsWith("node:") || builtinModules.includes(dep) || builtinModules.includes(pkg2);
}
function removeDeployer() {
  const t = babel__default.types;
  return {
    name: "remove-deployer",
    visitor: {
      NewExpression(path3, state) {
        const varDeclaratorPath = path3.findParent((path4) => t.isVariableDeclarator(path4.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path3.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        if (!state.hasReplaced) {
          state.hasReplaced = true;
          const newMastraObj = t.cloneNode(path3.node);
          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {
            const deployer = newMastraObj.arguments[0].properties.find(
              (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "deployer"
            );
            if (!deployer) {
              return;
            }
            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(
              (prop) => prop !== deployer
            );
            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {
              const deployerBinding = state.file.scope.getBinding(deployer.value.name);
              if (deployerBinding) {
                deployerBinding?.path?.parentPath?.remove();
              }
            }
            path3.replaceWith(newMastraObj);
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-deployer.ts
function removeDeployer2(mastraEntry, options) {
  return {
    name: "remove-deployer",
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve2, reject) => {
        babel.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeDeployer],
            sourceMaps: options?.sourcemap
          },
          (err, result) => {
            if (err) {
              return reject(err);
            }
            resolve2({
              code: result.code,
              map: result.map
            });
          }
        );
      });
    }
  };
}

// src/build/analyze/constants.ts
var DEPS_TO_IGNORE = ["#tools"];
var GLOBAL_EXTERNALS = [
  "pino",
  "pino-pretty",
  "@libsql/client",
  "pg",
  "libsql",
  "#tools",
  "typescript",
  "undici",
  "readable-stream"
];
var DEPRECATED_EXTERNALS = ["fastembed", "nodemailer", "jsdom", "sqlite3"];

// src/build/analyze/analyzeEntry.ts
function getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }) {
  const normalizedMastraEntry = slash(mastraEntry);
  let virtualPlugin = null;
  if (isVirtualFile) {
    virtualPlugin = virtual({
      "#entry": entry
    });
    entry = "#entry";
  }
  const plugins = [];
  if (virtualPlugin) {
    plugins.push(virtualPlugin);
  }
  plugins.push(
    ...[
      tsConfigPaths(),
      {
        name: "custom-alias-resolver",
        resolveId(id) {
          if (id === "#server") {
            return slash(fileURLToPath(import.meta.resolve("@mastra/deployer/server")));
          }
          if (id === "#mastra") {
            return normalizedMastraEntry;
          }
          if (id.startsWith("@mastra/server")) {
            return fileURLToPath(import.meta.resolve(id));
          }
        }
      },
      json(),
      esbuild(),
      commonjs({
        strictRequires: "debug",
        ignoreTryCatch: false,
        transformMixedEsModules: true,
        extensions: [".js", ".ts"]
      }),
      removeDeployer2(mastraEntry, { sourcemap: sourcemapEnabled }),
      esbuild()
    ]
  );
  return plugins;
}
async function captureDependenciesToOptimize(output, workspaceMap, projectRoot, initialDepsToOptimize, {
  logger,
  shouldCheckTransitiveDependencies
}) {
  const depsToOptimize = /* @__PURE__ */ new Map();
  if (!output.facadeModuleId) {
    throw new Error(
      "Something went wrong, we could not find the package name of the entry file. Please open an issue."
    );
  }
  let entryRootPath = projectRoot;
  if (!output.facadeModuleId.startsWith("\0virtual:")) {
    entryRootPath = await getPackageRootPath(output.facadeModuleId) || projectRoot;
  }
  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {
    if (isNodeBuiltin(dependency) || dependency.startsWith("#")) {
      continue;
    }
    const pkgName = getPackageName(dependency);
    let rootPath = null;
    let isWorkspace = false;
    if (pkgName) {
      rootPath = await getPackageRootPath(dependency, entryRootPath);
      isWorkspace = workspaceMap.has(pkgName);
    }
    const normalizedRootPath = rootPath ? slash(rootPath) : null;
    depsToOptimize.set(dependency, {
      exports: bindings,
      rootPath: normalizedRootPath,
      isWorkspace
    });
  }
  async function checkTransitiveDependencies(internalMap, maxDepth = 10, currentDepth = 0) {
    if (currentDepth >= maxDepth) {
      logger.warn("Maximum dependency depth reached while checking transitive dependencies.");
      return;
    }
    const depsSnapshot = new Map(depsToOptimize);
    let hasAddedDeps = false;
    for (const [dep, meta] of depsSnapshot) {
      if (!meta.isWorkspace || internalMap.has(dep)) {
        continue;
      }
      try {
        const resolvedPath = resolveFrom2(projectRoot, dep);
        if (!resolvedPath) {
          logger.warn(`Could not resolve path for workspace dependency ${dep}`);
          continue;
        }
        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, "", {
          workspaceMap,
          projectRoot,
          logger: noopLogger,
          sourcemapEnabled: false,
          initialDepsToOptimize: depsToOptimize
        });
        if (!analysis?.dependencies) {
          continue;
        }
        for (const [innerDep, innerMeta] of analysis.dependencies) {
          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {
            depsToOptimize.set(innerDep, innerMeta);
            internalMap.set(innerDep, innerMeta);
            hasAddedDeps = true;
          }
        }
      } catch (err) {
        logger.error(`Failed to resolve or analyze dependency ${dep}: ${err.message}`);
      }
    }
    if (hasAddedDeps) {
      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);
    }
  }
  if (shouldCheckTransitiveDependencies) {
    await checkTransitiveDependencies(initialDepsToOptimize);
  }
  const dynamicImports = output.dynamicImports.filter((d) => !DEPS_TO_IGNORE.includes(d));
  if (dynamicImports.length) {
    for (const dynamicImport of dynamicImports) {
      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {
        depsToOptimize.set(dynamicImport, {
          exports: ["*"],
          rootPath: null,
          isWorkspace: false
        });
      }
    }
  }
  return depsToOptimize;
}
async function analyzeEntry({
  entry,
  isVirtualFile
}, mastraEntry, {
  logger,
  sourcemapEnabled,
  workspaceMap,
  projectRoot,
  initialDepsToOptimize = /* @__PURE__ */ new Map(),
  // used to avoid infinite recursion
  shouldCheckTransitiveDependencies = false
}) {
  const optimizerBundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: isVirtualFile ? "#entry" : entry,
    treeshake: false,
    preserveSymlinks: true,
    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),
    external: DEPS_TO_IGNORE
  });
  const { output } = await optimizerBundler.generate({
    format: "esm",
    inlineDynamicImports: true
  });
  await optimizerBundler.close();
  const depsToOptimize = await captureDependenciesToOptimize(
    output[0],
    workspaceMap,
    projectRoot,
    initialDepsToOptimize,
    {
      logger,
      shouldCheckTransitiveDependencies
    }
  );
  return {
    dependencies: depsToOptimize,
    output: {
      code: output[0].code,
      map: output[0].map
    }
  };
}
var FilenameDeclarationRegex = /(?:const|let|var)\s+__filename/;
var DirnameDeclarationRegex = /(?:const|let|var)\s+__dirname/;
function esmShim() {
  const original = originalEsmShim();
  return {
    name: "esm-shim",
    renderChunk(code, chunk, opts, meta) {
      const hasFilename = code.includes("__filename");
      const hasDirname = code.includes("__dirname");
      const userDeclaredFilename = hasFilename && FilenameDeclarationRegex.test(code);
      const userDeclaredDirname = hasDirname && DirnameDeclarationRegex.test(code);
      if (userDeclaredFilename || userDeclaredDirname) {
        return null;
      }
      if (typeof original.renderChunk === "function") {
        return original.renderChunk.call(this, code, chunk, opts, meta);
      }
      return null;
    }
  };
}
function aliasHono() {
  return {
    name: "hono-alias",
    resolveId(id) {
      if (!id.startsWith("@hono/") && !id.startsWith("hono/") && id !== "hono" && id !== "hono-openapi") {
        return;
      }
      const path3 = import.meta.resolve(id);
      return fileURLToPath(path3);
    }
  };
}

// src/build/plugins/subpath-externals-resolver.ts
function subpathExternalsResolver(externals) {
  return {
    name: "subpath-externals-resolver",
    resolveId(id) {
      if (id.startsWith(".") || id.startsWith("/")) {
        return null;
      }
      const isPartOfExternals = externals.some((external) => isDependencyPartOfPackage(id, external));
      if (isPartOfExternals) {
        return {
          id,
          external: true
        };
      }
    }
  };
}
function nodeGypDetector() {
  const modulesToTrack = /* @__PURE__ */ new Set();
  const modulesToTrackPackageInfo = /* @__PURE__ */ new Map();
  return {
    name: "node-gyp-build-detector",
    moduleParsed(info) {
      if (!info.meta?.commonjs?.requires?.length) {
        return;
      }
      const hasNodeGypBuild = info.meta.commonjs.requires.some(
        (m) => m?.resolved?.id.endsWith("node-gyp-build/index.js")
      );
      if (!hasNodeGypBuild) {
        return;
      }
      modulesToTrack.add(info.id);
      modulesToTrackPackageInfo.set(info.id, getPackageInfo(info.id));
    },
    async generateBundle(options, bundle) {
      const binaryMapByChunk = /* @__PURE__ */ new Map();
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          for (const moduleId of chunk.moduleIds) {
            if (modulesToTrackPackageInfo.has(moduleId)) {
              const pkgInfo = await modulesToTrackPackageInfo.get(moduleId);
              if (!binaryMapByChunk.has(fileName)) {
                binaryMapByChunk.set(fileName, /* @__PURE__ */ new Set());
              }
              if (pkgInfo?.packageJson?.name) {
                binaryMapByChunk.get(fileName).add(pkgInfo.packageJson.name);
              }
            }
          }
        }
      }
      const binaryMapJson = Object.fromEntries(
        Array.from(binaryMapByChunk.entries()).map(([key, value]) => [key, Array.from(value)])
      );
      this.emitFile({
        type: "asset",
        name: "binary-map.json",
        source: `${JSON.stringify(binaryMapJson, null, 2)}`
      });
    }
  };
}
function moduleResolveMap(externals, projectRoot) {
  const importMap = /* @__PURE__ */ new Map();
  return {
    name: "module-resolve-map",
    moduleParsed(info) {
      if (info.importedIds.length === 0 || !info.id) {
        return;
      }
      for (const importedId of info.importedIds) {
        for (const external of externals) {
          if (isDependencyPartOfPackage(importedId, external)) {
            importMap.set(external, info.id);
          }
        }
      }
    },
    async generateBundle(options, bundle) {
      const resolveMap = /* @__PURE__ */ new Map();
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          for (const [external, resolvedFrom] of importMap) {
            if (chunk.moduleIds.includes(resolvedFrom)) {
              const fullPath = pathToFileURL(slash(join(projectRoot, fileName))).toString();
              const innerMap = resolveMap.get(fullPath) || /* @__PURE__ */ new Map();
              innerMap.set(external, pathToFileURL(slash(resolvedFrom)).toString());
              resolveMap.set(fullPath, innerMap);
            }
          }
        }
      }
      const resolveMapJson = Object.fromEntries(
        Array.from(resolveMap.entries()).map(([key, value]) => [key, Object.fromEntries(value.entries())])
      );
      this.emitFile({
        type: "asset",
        name: "module-resolve-map.json",
        source: `${JSON.stringify(resolveMapJson, null, 2)}`
      });
    }
  };
}

// src/build/analyze/bundleExternals.ts
function prepareEntryFileName(name, rootDir) {
  return rollupSafeName(name, rootDir);
}
function createVirtualDependencies(depsToOptimize, {
  projectRoot,
  workspaceRoot,
  outputDir,
  bundlerOptions
}) {
  const { isDev = false } = bundlerOptions || {};
  const fileNameToDependencyMap = /* @__PURE__ */ new Map();
  const optimizedDependencyEntries = /* @__PURE__ */ new Map();
  const rootDir = workspaceRoot || projectRoot;
  for (const [dep, { exports: exports2 }] of depsToOptimize.entries()) {
    const fileName = dep.replaceAll("/", "-");
    const virtualFile = [];
    const exportStringBuilder = [];
    for (const local of exports2) {
      if (local === "*") {
        virtualFile.push(`export * from '${dep}';`);
        continue;
      } else if (local === "default") {
        exportStringBuilder.push("default");
      } else {
        exportStringBuilder.push(local);
      }
    }
    const chunks = [];
    if (exportStringBuilder.length) {
      chunks.push(`{ ${exportStringBuilder.join(", ")} }`);
    }
    if (chunks.length) {
      virtualFile.push(`export ${chunks.join(", ")} from '${dep}';`);
    }
    let entryName = prepareEntryFileName(path2.join(outputDir, fileName), rootDir);
    fileNameToDependencyMap.set(entryName, dep);
    optimizedDependencyEntries.set(dep, {
      name: entryName,
      virtual: virtualFile.join("\n")
    });
  }
  if (isDev) {
    for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {
      if (!isWorkspace || !rootPath || !workspaceRoot) {
        continue;
      }
      const currentDepPath = optimizedDependencyEntries.get(dep);
      if (!currentDepPath) {
        continue;
      }
      const fileName = basename(currentDepPath.name);
      const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);
      fileNameToDependencyMap.set(entryName, dep);
      optimizedDependencyEntries.set(dep, {
        ...currentDepPath,
        name: entryName
      });
    }
  }
  return { optimizedDependencyEntries, fileNameToDependencyMap };
}
async function getInputPlugins2(virtualDependencies, {
  transpilePackages,
  workspaceMap,
  bundlerOptions,
  rootDir,
  externals
}) {
  const transpilePackagesMap = /* @__PURE__ */ new Map();
  for (const pkg2 of transpilePackages) {
    const dir = await getPackageRootPath(pkg2);
    if (dir) {
      transpilePackagesMap.set(pkg2, slash(dir));
    } else {
      transpilePackagesMap.set(pkg2, workspaceMap.get(pkg2)?.location ?? pkg2);
    }
  }
  return [
    virtual(
      Array.from(virtualDependencies.entries()).reduce(
        (acc, [dep, virtualDep]) => {
          acc[`#virtual-${dep}`] = virtualDep.virtual;
          return acc;
        },
        {}
      )
    ),
    subpathExternalsResolver(externals),
    transpilePackagesMap.size ? esbuild({
      format: "esm",
      include: [...transpilePackagesMap.values()].map((p) => {
        if (path2.isAbsolute(p)) {
          return new RegExp(`^${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
        } else {
          return new RegExp(`/${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
        }
      })
    }) : null,
    bundlerOptions.isDev ? {
      name: "alias-optimized-deps",
      async resolveId(id, importer, options) {
        if (!virtualDependencies.has(id)) {
          return null;
        }
        const info = virtualDependencies.get(id);
        const packageRootPath = path2.join(rootDir, path2.dirname(path2.dirname(path2.dirname(info.name))));
        const pkgJsonBuffer = await readFile(path2.join(packageRootPath, "package.json"), "utf-8");
        const pkgJson = JSON.parse(pkgJsonBuffer);
        if (!pkgJson) {
          return null;
        }
        const pkgName = pkgJson.name || "";
        let resolvedPath = resolve.exports(pkgJson, id.replace(pkgName, "."))?.[0];
        if (!resolvedPath) {
          resolvedPath = pkgJson.main ?? "index.js";
        }
        const resolved = await this.resolve(path2.posix.join(packageRootPath, resolvedPath), importer, options);
        return resolved;
      }
    } : null,
    optimizeLodashImports({
      include: "**/*.{js,ts,mjs,cjs}"
    }),
    commonjs({
      strictRequires: "strict",
      transformMixedEsModules: true,
      ignoreTryCatch: false
    }),
    bundlerOptions.isDev ? null : nodeResolve({
      preferBuiltins: true,
      exportConditions: ["node"]
    }),
    bundlerOptions.isDev ? esmShim() : null,
    // hono is imported from deployer, so we need to resolve from here instead of the project root
    aliasHono(),
    json(),
    nodeGypDetector(),
    moduleResolveMap(externals, rootDir),
    {
      name: "not-found-resolver",
      resolveId: {
        order: "post",
        async handler(id, importer) {
          if (!importer) {
            return null;
          }
          if (!id.endsWith(".node")) {
            return null;
          }
          const pkgInfo = await getPackageInfo(importer);
          const packageName = pkgInfo?.packageJson?.name || id;
          throw new MastraBaseError({
            id: "DEPLOYER_BUNDLE_EXTERNALS_MISSING_NATIVE_BUILD",
            domain: ErrorDomain.DEPLOYER,
            category: ErrorCategory.USER,
            details: {
              importFile: importer,
              packageName
            },
            text: `We found a possible binary dependency in your bundle. ${id} was not found when imported at ${importer}.
            
Please consider adding \`${packageName}\` to your externals, or updating this import to not end with ".node".
  
export const mastra = new Mastra({
  bundler: {
    externals: ["${packageName}"],
  }
})`
          });
        }
      }
    }
  ].filter(Boolean);
}
async function buildExternalDependencies(virtualDependencies, {
  externals,
  packagesToTranspile,
  workspaceMap,
  rootDir,
  outputDir,
  bundlerOptions
}) {
  if (virtualDependencies.size === 0) {
    return [];
  }
  const bundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: Array.from(virtualDependencies.entries()).reduce(
      (acc, [dep, virtualDep]) => {
        acc[virtualDep.name] = `#virtual-${dep}`;
        return acc;
      },
      {}
    ),
    external: externals,
    treeshake: bundlerOptions.isDev ? false : "safest",
    plugins: getInputPlugins2(virtualDependencies, {
      transpilePackages: packagesToTranspile,
      workspaceMap,
      bundlerOptions,
      rootDir,
      externals
    })
  });
  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);
  const { output } = await bundler.write({
    format: "esm",
    dir: rootDir,
    entryFileNames: "[name].mjs",
    // used to get the filename of the actual error
    sourcemap: true,
    /**
     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.
     * So we want to write them to the `.mastra/output` folder as well.
     */
    chunkFileNames: (chunkInfo) => {
      if (bundlerOptions.isDev) {
        const importedFromPackages = /* @__PURE__ */ new Set();
        for (const moduleId of chunkInfo.moduleIds) {
          const normalized = slash(moduleId);
          for (const [pkgName, pkgInfo] of workspaceMap.entries()) {
            const location = slash(pkgInfo.location);
            if (normalized.startsWith(location)) {
              importedFromPackages.add(pkgName);
              break;
            }
          }
        }
        if (importedFromPackages.size > 1) {
          throw new MastraBaseError({
            id: "DEPLOYER_BUNDLE_EXTERNALS_SHARED_CHUNK",
            domain: ErrorDomain.DEPLOYER,
            category: ErrorCategory.USER,
            details: {
              chunkName: chunkInfo.name,
              packages: JSON.stringify(Array.from(importedFromPackages))
            },
            text: `Please open an issue. We found a shared chunk "${chunkInfo.name}" used by multiple workspace packages: ${Array.from(importedFromPackages).join(", ")}.`
          });
        }
        if (importedFromPackages.size === 1) {
          const [pkgName] = importedFromPackages;
          const workspaceLocation = workspaceMap.get(pkgName).location;
          return prepareEntryFileName(getCompiledDepCachePath(workspaceLocation, "[name].mjs"), rootDir);
        }
      }
      return `${outputDirRelative}/[name].mjs`;
    },
    assetFileNames: `${outputDirRelative}/[name][extname]`,
    hoistTransitiveImports: false
  });
  await bundler.close();
  return output;
}
function findExternalImporter(module, external, allOutputs) {
  const capturedFiles = /* @__PURE__ */ new Set();
  for (const id of module.imports) {
    if (isDependencyPartOfPackage(id, external)) {
      return module;
    } else {
      if (id.endsWith(".mjs")) {
        capturedFiles.add(id);
      }
    }
  }
  for (const file of capturedFiles) {
    const nextModule = allOutputs.find((o) => o.fileName === file);
    if (nextModule) {
      const importer = findExternalImporter(nextModule, external, allOutputs);
      if (importer) {
        return importer;
      }
    }
  }
  return null;
}
async function bundleExternals(depsToOptimize, outputDir, options) {
  const { workspaceRoot = null, workspaceMap = /* @__PURE__ */ new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;
  const {
    externals: customExternals = [],
    transpilePackages = [],
    isDev = false} = bundlerOptions || {};
  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...customExternals];
  const workspacePackagesNames = Array.from(workspaceMap.keys());
  const packagesToTranspile = /* @__PURE__ */ new Set([...transpilePackages, ...workspacePackagesNames]);
  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {
    workspaceRoot,
    outputDir,
    projectRoot,
    bundlerOptions: {
      isDev
    }
  });
  const output = await buildExternalDependencies(optimizedDependencyEntries, {
    externals: allExternals,
    packagesToTranspile,
    workspaceMap,
    rootDir: workspaceRoot || projectRoot,
    outputDir,
    bundlerOptions: {
      isDev
    }
  });
  const moduleResolveMap2 = /* @__PURE__ */ new Map();
  const filteredChunks = output.filter((o) => o.type === "chunk");
  for (const o of filteredChunks.filter((o2) => o2.isEntry || o2.isDynamicEntry)) {
    for (const external of allExternals) {
      if (DEPS_TO_IGNORE.includes(external)) {
        continue;
      }
      const importer = findExternalImporter(o, external, filteredChunks);
      if (importer) {
        const fullPath = path2.join(workspaceRoot || projectRoot, importer.fileName);
        let innerMap = moduleResolveMap2.get(fullPath);
        if (!innerMap) {
          innerMap = /* @__PURE__ */ new Map();
          moduleResolveMap2.set(fullPath, innerMap);
        }
        if (importer.moduleIds.length) {
          innerMap.set(
            external,
            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith("\0virtual:#virtual") ? importer.moduleIds[importer.moduleIds.length - 2] : importer.moduleIds[importer.moduleIds.length - 1]
          );
        }
      }
    }
  }
  const usedExternals = /* @__PURE__ */ Object.create(null);
  for (const [fullPath, innerMap] of moduleResolveMap2) {
    const innerObj = /* @__PURE__ */ Object.create(null);
    for (const [external, value] of innerMap) {
      innerObj[external] = value;
    }
    usedExternals[fullPath] = innerObj;
  }
  return { output, fileNameToDependencyMap, usedExternals };
}

// ../../node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js
var UNKNOWN_FUNCTION = "<unknown>";
function parse(stackString) {
  var lines = stackString.split("\n");
  return lines.reduce(function(stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
    if (parseResult) {
      stack.push(parseResult);
    }
    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
function parseChrome(line) {
  var parts = chromeRe.exec(line);
  if (!parts) {
    return null;
  }
  var isNative = parts[2] && parts[2].indexOf("native") === 0;
  var isEval = parts[2] && parts[2].indexOf("eval") === 0;
  var submatch = chromeEvalRe.exec(parts[2]);
  if (isEval && submatch != null) {
    parts[2] = submatch[1];
    parts[3] = submatch[2];
    parts[4] = submatch[3];
  }
  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}
var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinjs(line) {
  var parts = winjsRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGecko(line) {
  var parts = geckoRe.exec(line);
  if (!parts) {
    return null;
  }
  var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
  var submatch = geckoEvalRe.exec(parts[3]);
  if (isEval && submatch != null) {
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(",") : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}
var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}
var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseNode(line) {
  var parts = nodeRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

// src/build/analyze.ts
function throwExternalDependencyError({
  errorId,
  moduleName,
  packageName,
  messagePrefix
}) {
  throw new MastraError({
    id: errorId,
    domain: ErrorDomain.DEPLOYER,
    category: ErrorCategory.USER,
    details: {
      importFile: moduleName,
      packageName
    },
    text: `${messagePrefix} \`${packageName}\` to your externals.

export const mastra = new Mastra({
  bundler: {
    externals: ["${packageName}"],
  }
})`
  });
}
function getPackageNameFromBundledModuleName(moduleName) {
  const chunks = moduleName.split("-");
  if (!chunks.length) {
    return moduleName;
  }
  if (chunks[0]?.startsWith("@")) {
    return chunks.slice(0, 2).join("/");
  }
  return chunks[0];
}
function validateError(err, file, {
  binaryMapData,
  workspaceMap
}) {
  let moduleName = null;
  let errorConfig = null;
  if (err instanceof ValidationError) {
    const parsedStack = parse(err.stack);
    if (err.type === "TypeError") {
      const pkgNameRegex = /.*node_modules\/([^\/]+)\//;
      const stacktraceFrame = parsedStack.find((frame) => frame.file && pkgNameRegex.test(frame.file));
      if (stacktraceFrame) {
        const match = stacktraceFrame.file.match(pkgNameRegex);
        moduleName = match?.[1] ?? getPackageNameFromBundledModuleName(basename$1(file.name));
      } else {
        moduleName = getPackageNameFromBundledModuleName(basename$1(file.name));
      }
      errorConfig = {
        id: "DEPLOYER_ANALYZE_TYPE_ERROR",
        messagePrefix: `Mastra wasn't able to bundle "${moduleName}", might be an older commonJS module. Please add`
      };
    } else if (err.stack?.includes?.("[ERR_MODULE_NOT_FOUND]")) {
      moduleName = err.message.match(/Cannot find package '([^']+)'/)?.[1];
      const parentModuleName = getPackageNameFromBundledModuleName(basename$1(file.name));
      errorConfig = {
        id: "DEPLOYER_ANALYZE_MODULE_NOT_FOUND",
        messagePrefix: `Mastra wasn't able to build your project, We couldn't load "${moduleName}" from "${parentModuleName}". Make sure "${moduleName}" is installed or add`
      };
      if (moduleName === parentModuleName) {
        return;
      }
    }
  }
  if (err.message.includes("No native build was found")) {
    const pkgName = getPackageNameFromBundledModuleName(basename$1(file.name));
    moduleName = binaryMapData[file.fileName]?.[0] ?? pkgName;
    errorConfig = {
      id: "DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD",
      messagePrefix: "We found a binary dependency in your bundle but we cannot bundle it yet. Please add"
    };
  }
  if (moduleName && workspaceMap.has(moduleName)) {
    throw new MastraError({
      id: "DEPLOYER_ANALYZE_ERROR_IN_WORKSPACE",
      domain: ErrorDomain.DEPLOYER,
      category: ErrorCategory.USER,
      details: {
        // importFile: moduleName,
        packageName: moduleName
      },
      text: `We found an error in the ${moduleName} workspace package. Please find the offending package and fix the error.
  Error: ${err.stack}`
    });
  }
  if (errorConfig && moduleName) {
    throwExternalDependencyError({
      errorId: errorConfig.id,
      moduleName,
      packageName: moduleName,
      messagePrefix: errorConfig.messagePrefix
    });
  }
}
async function validateFile(root, file, {
  binaryMapData,
  moduleResolveMapLocation,
  logger,
  workspaceMap
}) {
  try {
    if (!file.isDynamicEntry && file.isEntry) {
      await validate(join(root, file.fileName), {
        moduleResolveMapLocation,
        injectESMShim: false
      });
    }
  } catch (err) {
    let errorToHandle = err;
    if (err instanceof ValidationError && err.type === "ReferenceError" && (err.message.startsWith("__dirname") || err.message.startsWith("__filename"))) {
      try {
        await validate(join(root, file.fileName), {
          moduleResolveMapLocation,
          injectESMShim: true
        });
        errorToHandle = null;
      } catch (err2) {
        errorToHandle = err2;
      }
    }
    if (errorToHandle instanceof Error) {
      validateError(errorToHandle, file, { binaryMapData, workspaceMap });
    }
  }
}
async function validateOutput({
  output,
  reverseVirtualReferenceMap,
  usedExternals,
  outputDir,
  projectRoot,
  workspaceMap
}, logger) {
  const result = {
    dependencies: /* @__PURE__ */ new Map(),
    externalDependencies: /* @__PURE__ */ new Set(),
    workspaceMap
  };
  for (const deps of Object.values(usedExternals)) {
    for (const dep of Object.keys(deps)) {
      result.externalDependencies.add(dep);
    }
  }
  let binaryMapData = {};
  if (existsSync(join(outputDir, "binary-map.json"))) {
    const binaryMap = await readFile(join(outputDir, "binary-map.json"), "utf-8");
    binaryMapData = JSON.parse(binaryMap);
  }
  for (const file of output) {
    if (file.type === "asset") {
      continue;
    }
    logger.debug(`Validating if ${file.fileName} is a valid module.`);
    if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
      result.dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
    }
    await validateFile(projectRoot, file, {
      binaryMapData,
      moduleResolveMapLocation: join(outputDir, "module-resolve-map.json"),
      logger,
      workspaceMap
    });
  }
  return result;
}
async function analyzeBundle(entries, mastraEntry, {
  outputDir,
  projectRoot,
  isDev = false,
  bundlerOptions: _bundlerOptions
}, logger) {
  const mastraConfig = await readFile(mastraEntry, "utf-8");
  const mastraConfigResult = {
    hasValidConfig: false
  };
  await babel.transformAsync(mastraConfig, {
    filename: mastraEntry,
    presets: [import.meta.resolve("@babel/preset-typescript")],
    plugins: [checkConfigExport(mastraConfigResult)]
  });
  if (!mastraConfigResult.hasValidConfig) {
    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:
export const mastra = new Mastra({
  // your options
})
  
If you think your configuration is valid, please open an issue.`);
  }
  const { enableEsmShim = true } = _bundlerOptions || {};
  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);
  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });
  let index = 0;
  const depsToOptimize = /* @__PURE__ */ new Map();
  const { externals: customExternals = [] } = bundlerOptions || {};
  const allExternals = [...GLOBAL_EXTERNALS, ...customExternals];
  logger.info("Analyzing dependencies...");
  const allUsedExternals = /* @__PURE__ */ new Set();
  for (const entry of entries) {
    const isVirtualFile = entry.includes("\n") || !existsSync(entry);
    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {
      logger,
      sourcemapEnabled: bundlerOptions?.sourcemap ?? false,
      workspaceMap,
      projectRoot,
      shouldCheckTransitiveDependencies: isDev
    });
    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);
    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {
      const isPartOfExternals = allExternals.some((external) => isDependencyPartOfPackage(dep, external));
      if (isPartOfExternals) {
        allUsedExternals.add(dep);
        continue;
      }
      if (depsToOptimize.has(dep)) {
        const existingEntry = depsToOptimize.get(dep);
        depsToOptimize.set(dep, {
          ...existingEntry,
          exports: [.../* @__PURE__ */ new Set([...existingEntry.exports, ...metadata.exports])]
        });
      } else {
        depsToOptimize.set(dep, metadata);
      }
    }
  }
  if (isDev) {
    for (const [dep, metadata] of depsToOptimize.entries()) {
      if (!metadata.isWorkspace) {
        depsToOptimize.delete(dep);
      }
    }
  }
  const sortedDeps = Array.from(depsToOptimize.keys()).sort();
  logger.info("Optimizing dependencies...");
  logger.debug(`${sortedDeps.map((key) => `- ${key}`).join("\n")}`);
  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {
    bundlerOptions: {
      ...bundlerOptions,
      externals: allExternals,
      enableEsmShim,
      isDev
    },
    projectRoot,
    workspaceRoot,
    workspaceMap
  });
  const result = await validateOutput(
    {
      output,
      reverseVirtualReferenceMap: fileNameToDependencyMap,
      usedExternals,
      outputDir,
      projectRoot: workspaceRoot || projectRoot,
      workspaceMap
    },
    logger
  );
  return {
    ...result,
    externalDependencies: /* @__PURE__ */ new Set([...result.externalDependencies, ...Array.from(allUsedExternals)])
  };
}

export { aliasHono, analyzeBundle, esbuild, esmShim, extractMastraOption, getBundlerOptions, getWorkspaceInformation, removeAllOptionsFromMastraExcept, removeDeployer2 as removeDeployer, subpathExternalsResolver, tsConfigPaths };
//# sourceMappingURL=chunk-C3343ELD.js.map
//# sourceMappingURL=chunk-C3343ELD.js.map