{"version":3,"sources":["../../src/validator/custom-resolver.ts"],"names":[],"mappings":";;;;;;AAOA,IAAM,KAAA,uBAAY,GAAA,EAAoC;AAOtD,SAAS,gBAAgB,SAAA,EAA4B;AACnD,EAAA,OACE,cAAA,CAAe,QAAA,CAAS,SAAS,CAAA,IACjC,UAAU,UAAA,CAAW,OAAO,CAAA,IAC5B,cAAA,CAAe,QAAA,CAAS,SAAA,CAAU,OAAA,CAAQ,QAAA,EAAU,EAAE,CAAC,CAAA;AAE3D;AAOA,SAAS,eAAe,SAAA,EAA4B;AAClD,EAAA,OACE,SAAA,CAAU,UAAA,CAAW,IAAI,CAAA,IACzB,UAAU,UAAA,CAAW,KAAK,CAAA,IAC1B,SAAA,CAAU,UAAA,CAAW,GAAG,CAAA,IACxB,cAAA,CAAe,KAAK,SAAS,CAAA;AAEjC;AAQA,eAAe,aAAA,CAAc,WAAmB,GAAA,EAAqC;AACnF,EAAA,IAAI,CAAC,MAAM,IAAA,EAAM;AACf,IAAA,IAAI,wBAAA,GAA2B,QAAQ,GAAA,CAAI,UAAA;AAC3C,IAAA,IAAI,CAAC,wBAAA,EAA0B;AAC7B,MAAA,wBAAA,GAA2B,IAAA,CAAK,OAAA,CAAQ,GAAA,EAAI,EAAG,yBAAyB,CAAA;AAAA,IAC1E;AAEA,IAAA,IAAI,mBAA2D,EAAC;AAChE,IAAA,IAAI,UAAA,CAAW,wBAAwB,CAAA,EAAG;AACxC,MAAA,gBAAA,GAAmB,KAAK,KAAA,CAAM,MAAM,QAAA,CAAS,wBAAA,EAA0B,OAAO,CAAC,CAAA;AAAA,IAIjF;AAEA,IAAA,KAAA,MAAW,CAAC,EAAA,EAAI,IAAI,KAAK,MAAA,CAAO,OAAA,CAAQ,gBAAgB,CAAA,EAAG;AACzD,MAAA,KAAA,CAAM,GAAA,CAAI,IAAI,IAAI,CAAA;AAAA,IACpB;AAAA,EACF;AAEA,EAAA,MAAM,SAAA,GAAY,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAC/B,EAAA,IAAI,CAAC,SAAA,EAAW;AACd,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,SAAS,CAAA,CAAE,KAAK,CAAA,QAAA,KAAY,yBAAA,CAA0B,SAAA,EAAW,QAAQ,CAAC,CAAA;AAC7G,EAAA,IAAI,CAAC,cAAA,EAAgB;AACnB,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,MAAM,eAAA,GAAkB,UAAU,cAAc,CAAA;AAChD,EAAA,OAAO,eAAA;AACT;AAEA,eAAsB,OAAA,CACpB,SAAA,EACA,OAAA,EACA,WAAA,EACA;AAEA,EAAA,IAAI,eAAA,CAAgB,SAAS,CAAA,EAAG;AAC9B,IAAA,OAAO,WAAA,CAAY,WAAW,OAAO,CAAA;AAAA,EACvC;AAEA,EAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,IAAA,OAAO,WAAA,CAAY,WAAW,OAAO,CAAA;AAAA,EACvC;AAEA,EAAA,IAAI,QAAQ,SAAA,EAAW;AACrB,IAAA,MAAM,UAAA,GAAa,MAAM,aAAA,CAAc,SAAA,EAAW,QAAQ,SAAS,CAAA;AAEnE,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,OAAO,YAAY,SAAA,EAAW;AAAA,QAC5B,GAAG,OAAA;AAAA,QACH,SAAA,EAAW;AAAA,OACZ,CAAA;AAAA,IACH;AAAA,EACF;AAGA,EAAA,OAAO,WAAA,CAAY,WAAW,OAAO,CAAA;AACvC","file":"custom-resolver.js","sourcesContent":["import { existsSync } from 'node:fs';\nimport { readFile } from 'node:fs/promises';\nimport type { ResolveHookContext } from 'node:module';\nimport { builtinModules } from 'node:module';\nimport { join } from 'node:path';\nimport { isDependencyPartOfPackage } from '../build/utils';\n\nconst cache = new Map<string, Record<string, string>>();\n\n/**\n * Check if a module is a Node.js builtin module\n * @param specifier - Module specifier\n * @returns True if it's a builtin module\n */\nfunction isBuiltinModule(specifier: string): boolean {\n  return (\n    builtinModules.includes(specifier) ||\n    specifier.startsWith('node:') ||\n    builtinModules.includes(specifier.replace(/^node:/, ''))\n  );\n}\n\n/**\n * Check if a module specifier is a relative or absolute path\n * @param specifier - Module specifier\n * @returns True if it's a relative or absolute path\n */\nfunction isRelativePath(specifier: string): boolean {\n  return (\n    specifier.startsWith('./') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('/') ||\n    /^[a-zA-Z]:\\\\/.test(specifier)\n  ); // Windows absolute path\n}\n\n/**\n * Get the path to resolve any external packages from\n *\n * @param url\n * @returns\n */\nasync function getParentPath(specifier: string, url: string): Promise<string | null> {\n  if (!cache.size) {\n    let moduleResolveMapLocation = process.env.MODULE_MAP;\n    if (!moduleResolveMapLocation) {\n      moduleResolveMapLocation = join(process.cwd(), 'module-resolve-map.json');\n    }\n\n    let moduleResolveMap: Record<string, Record<string, string>> = {};\n    if (existsSync(moduleResolveMapLocation)) {\n      moduleResolveMap = JSON.parse(await readFile(moduleResolveMapLocation, 'utf-8')) as Record<\n        string,\n        Record<string, string>\n      >;\n    }\n\n    for (const [id, rest] of Object.entries(moduleResolveMap)) {\n      cache.set(id, rest);\n    }\n  }\n\n  const importers = cache.get(url);\n  if (!importers) {\n    return null;\n  }\n\n  const matchedPackage = Object.keys(importers).find(external => isDependencyPartOfPackage(specifier, external));\n  if (!matchedPackage) {\n    return null;\n  }\n  const specifierParent = importers[matchedPackage]!;\n  return specifierParent;\n}\n\nexport async function resolve(\n  specifier: string,\n  context: ResolveHookContext,\n  nextResolve: (specifier: string, context: ResolveHookContext) => Promise<{ url: string }>,\n) {\n  // Don't modify builtin modules\n  if (isBuiltinModule(specifier)) {\n    return nextResolve(specifier, context);\n  }\n\n  if (isRelativePath(specifier)) {\n    return nextResolve(specifier, context);\n  }\n\n  if (context.parentURL) {\n    const parentPath = await getParentPath(specifier, context.parentURL);\n\n    if (parentPath) {\n      return nextResolve(specifier, {\n        ...context,\n        parentURL: parentPath,\n      });\n    }\n  }\n\n  // Continue resolution with the modified path\n  return nextResolve(specifier, context);\n}\n"]}