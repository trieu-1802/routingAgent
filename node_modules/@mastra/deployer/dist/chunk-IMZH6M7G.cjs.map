{"version":3,"sources":["../src/validator/validate.ts","../src/build/babel/remove-all-options-except.ts","../src/build/babel/remove-all-options-bundler.ts","../src/build/plugins/esbuild.ts","../src/build/plugins/tsconfig-paths.ts","../src/build/babel/remove-non-referenced-nodes.ts","../src/build/plugins/remove-unused-references.ts","../src/build/shared/extract-mastra-option.ts","../src/build/bundlerOptions.ts","../src/build/babel/check-config-export.ts","../src/bundler/workspaceDependencies.ts","../src/build/isNodeBuiltin.ts","../src/build/babel/remove-deployer.ts","../src/build/plugins/remove-deployer.ts","../src/build/analyze/constants.ts","../src/build/analyze/analyzeEntry.ts","../src/build/plugins/esm-shim.ts","../src/build/plugins/hono-alias.ts","../src/build/plugins/subpath-externals-resolver.ts","../src/build/plugins/node-gyp-detector.ts","../src/build/plugins/module-resolve-map.ts","../src/build/analyze/bundleExternals.ts","../../../node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js","../src/build/analyze.ts"],"names":["resolve","nodeSpawn","slash","dirname","babel","path","originalEsbuild","fs","stripJsonComments","tsConfigPath","createHandler","normalize","resolved","babel3","rollup","optimizeLodashImports","commonjs","json","babel4","result","createWorkspacesCache","pkg","findWorkspaces","findWorkspacesRoot","builtinModules","removeDeployer","babel7","virtual","fileURLToPath","logger","getPackageRootPath","getPackageName","resolveFrom","noopLogger","originalEsmShim","isDependencyPartOfPackage","getPackageInfo","pathToFileURL","join","rollupSafeName","exports","path2","basename","getCompiledDepCachePath","getInputPlugins","readFile","nodeResolve","MastraBaseError","ErrorDomain","ErrorCategory","moduleResolveMap","o","MastraError","err","existsSync","babel8","writeFile"],"mappings":"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","file":"chunk-IMZH6M7G.cjs","sourcesContent":["import { spawn as nodeSpawn } from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport { dirname } from 'node:path';\nimport { slash } from '../build/utils';\n\ntype ValidationArgs = {\n  message: string;\n  type: string;\n  stack: string;\n};\n\nexport class ValidationError extends Error {\n  public readonly type: string;\n  public readonly stack: string;\n  constructor(args: ValidationArgs) {\n    super(args.message);\n    this.type = args.type;\n    this.stack = args.stack;\n  }\n}\n\n/**\n * Promisified version of Node.js spawn function\n *\n * @param command - The command to run\n * @param args - List of string arguments\n * @param options - Spawn options\n * @returns Promise that resolves with the exit code when the process completes\n */\nfunction spawn(command: string, args: string[] = [], options: SpawnOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let validationError: ValidationArgs | null = null;\n    const childProcess = nodeSpawn(command, args, {\n      // stdio: 'inherit',\n      ...options,\n    });\n\n    childProcess.on('error', error => {\n      reject(error);\n    });\n\n    let stderr = '';\n    childProcess.stderr?.on('data', message => {\n      try {\n        validationError = JSON.parse(message.toString());\n      } catch {\n        stderr += message;\n      }\n    });\n\n    childProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        if (validationError) {\n          reject(new ValidationError(validationError));\n        } else {\n          reject(new Error(stderr));\n        }\n      }\n    });\n  });\n}\n\nexport function validate(\n  file: string,\n  { injectESMShim = false, moduleResolveMapLocation }: { injectESMShim?: boolean; moduleResolveMapLocation: string },\n) {\n  let prefixCode = '';\n  if (injectESMShim) {\n    prefixCode = `import { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nglobalThis.__filename = fileURLToPath(import.meta.url);\nglobalThis.__dirname = dirname(__filename);\n    `;\n  }\n\n  // Used to log a proper error we can parse instead of trying to do some fancy string grepping\n  function errorHandler(err: Error) {\n    console.error(\n      JSON.stringify({\n        type: err.name,\n        message: err.message,\n        stack: err.stack,\n      }),\n    );\n    process.exit(1);\n  }\n\n  return spawn(\n    process.execPath,\n    [\n      '--import',\n      import.meta.resolve('@mastra/deployer/loader'),\n      '--input-type=module',\n      '--enable-source-maps',\n      '-e',\n      `${prefixCode};import('file://${slash(file)}').catch(err => {\n        ${errorHandler.toString()}\n        errorHandler(err);\n      })`.replaceAll(/\\n/g, ''),\n    ],\n    {\n      env: {\n        ...process.env,\n        MODULE_MAP: `${moduleResolveMapLocation}`,\n      },\n      cwd: dirname(file),\n    },\n  );\n}\n","import babel from '@babel/core';\nimport type { NodePath, types } from '@babel/core';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function removeAllOptionsFromMastraExcept(\n  result: { hasCustomConfig: boolean },\n  option: keyof MastraConfig,\n  logger?: IMastraLogger,\n) {\n  const t = babel.types;\n\n  return {\n    name: 'remove-all-except-' + option + '-config',\n    visitor: {\n      ExportNamedDeclaration: {\n        // remove all exports\n        exit(path) {\n          path.remove();\n        },\n      },\n\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        let mastraArgs = t.objectExpression([]);\n        if (t.isObjectExpression(path.node.arguments[0])) {\n          mastraArgs = path.node.arguments[0];\n        }\n\n        let telemetry = mastraArgs.properties.find(\n          // @ts-ignore\n          prop => prop.key.name === option,\n        );\n        let telemetryValue: types.Expression = t.objectExpression([]);\n\n        const programPath = path.scope.getProgramParent().path as NodePath<types.Program> | undefined;\n        if (!programPath) {\n          return;\n        }\n\n        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {\n          result.hasCustomConfig = true;\n          telemetryValue = telemetry.value;\n\n          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {\n            const telemetryBinding = state.file.scope.getBinding(option)!;\n\n            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {\n              const id = path.scope.generateUidIdentifier(option);\n\n              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init!));\n              telemetryValue = id;\n            }\n          }\n        }\n\n        // add the deployer export\n        const exportDeclaration = t.exportNamedDeclaration(\n          t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), telemetryValue)]),\n          [],\n        );\n\n        programPath.node.body.push(exportDeclaration);\n      },\n\n      Program: {\n        exit(path) {\n          // Add a fallback export if no mastra configuration was found\n          const hasExport = path.node.body.some(\n            node => node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration',\n          );\n\n          if (!hasExport) {\n            if (logger) {\n              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:\nexport const mastra = new Mastra({\n  ${option}: <value>\n})\n\n`);\n            }\n\n            const fallbackExportDeclaration = t.exportNamedDeclaration(\n              t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),\n              [],\n            );\n            path.node.body.push(fallbackExportDeclaration);\n          }\n        },\n      },\n    },\n  } as babel.PluginObj;\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport { removeAllOptionsFromMastraExcept } from './remove-all-options-except';\n\nexport function removeAllOptionsExceptBundler(result: { hasCustomConfig: boolean }, logger?: IMastraLogger) {\n  return removeAllOptionsFromMastraExcept(result, 'bundler', logger);\n}\n","import originalEsbuild from 'rollup-plugin-esbuild';\n\nexport function esbuild(options: Parameters<typeof originalEsbuild>[0] = {}) {\n  return originalEsbuild({\n    target: 'node20',\n    platform: 'node',\n    minify: false,\n    ...options,\n  });\n}\n","import fs from 'node:fs';\nimport path, { normalize } from 'node:path';\nimport resolveFrom from 'resolve-from';\nimport type { Plugin } from 'rollup';\nimport stripJsonComments from 'strip-json-comments';\nimport type { RegisterOptions } from 'typescript-paths';\nimport { createHandler } from 'typescript-paths';\n\nconst PLUGIN_NAME = 'tsconfig-paths';\n\nexport type PluginOptions = Omit<RegisterOptions, 'loggerID'> & { localResolve?: boolean };\n\n/**\n * Check if a tsconfig file has path mappings configured.\n * Exported for testing purposes.\n *\n * @param tsConfigPath - Path to the tsconfig.json file\n * @returns true if the tsconfig has paths configured, false otherwise\n */\nexport function hasPaths(tsConfigPath: string): boolean {\n  try {\n    const content = fs.readFileSync(tsConfigPath, 'utf8');\n    const config = JSON.parse(stripJsonComments(content));\n    return !!(config.compilerOptions?.paths && Object.keys(config.compilerOptions.paths).length > 0);\n  } catch {\n    return false;\n  }\n}\n\nexport function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve }: PluginOptions = {}): Plugin {\n  const handlerCache = new Map<string, ReturnType<typeof createHandler>>();\n\n  // Find tsconfig.json file starting from a directory and walking up\n  function findTsConfigForFile(filePath: string): string | null {\n    let currentDir = path.dirname(filePath);\n    const root = path.parse(currentDir).root;\n\n    while (currentDir !== root) {\n      const tsConfigPath = path.join(currentDir, 'tsconfig.json');\n\n      if (fs.existsSync(tsConfigPath)) {\n        // Check if this tsconfig has path mappings\n        if (hasPaths(tsConfigPath)) {\n          return tsConfigPath;\n        }\n      }\n\n      // Also check for tsconfig.base.json (common in NX)\n      const tsConfigBasePath = path.join(currentDir, 'tsconfig.base.json');\n      if (fs.existsSync(tsConfigBasePath)) {\n        if (hasPaths(tsConfigBasePath)) {\n          return tsConfigBasePath;\n        }\n      }\n\n      currentDir = path.dirname(currentDir);\n    }\n\n    return null;\n  }\n\n  // Get or create handler for a specific tsconfig file\n  function getHandlerForFile(filePath: string): ReturnType<typeof createHandler> | null {\n    // If a specific tsConfigPath was provided, use it\n    if (tsConfigPath && typeof tsConfigPath === 'string') {\n      if (!handlerCache.has(tsConfigPath)) {\n        handlerCache.set(\n          tsConfigPath,\n          createHandler({\n            log: () => {},\n            tsConfigPath,\n            respectCoreModule,\n            falllback: moduleName => fs.existsSync(moduleName),\n          }),\n        );\n      }\n      return handlerCache.get(tsConfigPath)!;\n    }\n\n    // Find appropriate tsconfig for this file\n    const configPath = findTsConfigForFile(filePath);\n    if (!configPath) {\n      return null;\n    }\n\n    // Cache handlers to avoid recreation\n    if (!handlerCache.has(configPath)) {\n      handlerCache.set(\n        configPath,\n        createHandler({\n          log: () => {},\n          tsConfigPath: configPath,\n          respectCoreModule,\n          falllback: moduleName => fs.existsSync(moduleName),\n        }),\n      );\n    }\n\n    return handlerCache.get(configPath)!;\n  }\n\n  // Simple alias resolution using dynamic handler\n  function resolveAlias(request: string, importer: string): string | null | undefined {\n    // Get the appropriate handler for this file\n    const dynamicHandler = getHandlerForFile(importer);\n    if (!dynamicHandler) {\n      return null;\n    }\n\n    const resolved = dynamicHandler(request, normalize(importer));\n    return resolved;\n  }\n\n  return {\n    name: PLUGIN_NAME,\n    async resolveId(request, importer, options) {\n      if (!importer || request.startsWith('\\0') || importer.charCodeAt(0) === 0) {\n        return null;\n      }\n\n      const moduleName = resolveAlias(request, importer);\n      // No tsconfig alias found, so we need to resolve it normally\n      if (!moduleName) {\n        let importerMeta: { [PLUGIN_NAME]?: { resolved?: boolean } } = {};\n\n        const resolved = await this.resolve(request, importer, { skipSelf: true, ...options });\n        if (!resolved) {\n          return null;\n        }\n\n        // If localResolve is true, we need to check if the importer has been resolved by the tsconfig-paths plugin\n        // if so, we need to resolve the request from the importer instead of the root and mark it as external\n        if (localResolve) {\n          const importerInfo = this.getModuleInfo(importer);\n          importerMeta = importerInfo?.meta || {};\n\n          if (!request.startsWith('./') && !request.startsWith('../') && importerMeta?.[PLUGIN_NAME]?.resolved) {\n            return {\n              ...resolved,\n              external: !request.startsWith('hono/') && request !== 'hono',\n            };\n          }\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...(resolved.meta || {}),\n            ...importerMeta,\n          },\n        };\n      }\n\n      // When a module does not have an extension, we need to resolve it to a file\n      if (!path.extname(moduleName)) {\n        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });\n\n        if (!resolved) {\n          return null;\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...resolved.meta,\n            [PLUGIN_NAME]: {\n              resolved: true,\n            },\n          },\n        };\n      }\n\n      // Always pass through bundler's resolution to ensure proper path normalization\n      const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });\n\n      if (!resolved) {\n        return null;\n      }\n\n      return {\n        ...resolved,\n        meta: {\n          ...resolved.meta,\n          [PLUGIN_NAME]: {\n            resolved: true,\n          },\n        },\n      };\n    },\n  } satisfies Plugin;\n}\n","import babel from '@babel/core';\n\nexport function removeNonReferencedNodes() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-non-referenced-nodes',\n    visitor: {\n      Program(path) {\n        // Get the scope information\n        const scope = path.scope;\n\n        // Filter body to keep only referenced nodes\n        const currentBody = path.get('body');\n        const filteredBody = currentBody.filter(childPath => {\n          if (childPath.isExportDeclaration()) {\n            return true;\n          }\n\n          // For variable declarations, check if any declared variables are referenced\n          if (childPath.isVariableDeclaration()) {\n            return childPath.node.declarations.some(decl => {\n              if (!t.isIdentifier(decl.id)) {\n                return false;\n              }\n\n              const name = decl.id.name;\n              const binding = scope.getBinding(name);\n              // Keep if it has references or is exported\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // For function/class declarations, check if they're referenced\n          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {\n            if (!t.isIdentifier(childPath.node.id)) {\n              return false;\n            }\n\n            const name = childPath.node.id.name;\n            const binding = scope.getBinding(name);\n            return binding && (binding.referenced || binding.referencePaths.length > 0);\n          }\n\n          // For imports, check if any imported items are referenced\n          if (childPath.isImportDeclaration()) {\n            return childPath.node.specifiers.some(specifier => {\n              const importedName = specifier.local.name;\n              const binding = scope.getBinding(importedName);\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // Default to keeping other node types\n          return false;\n        });\n\n        // Replace the program body with filtered nodes\n        path.set(\n          'body',\n          filteredBody.map(p => p.node),\n        );\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport { removeNonReferencedNodes } from '../babel/remove-non-referenced-nodes';\n\nexport function recursiveRemoveNonReferencedNodes(code: string) {\n  return new Promise<{ code: string; map: any }>(async (resolve, reject) => {\n    babel.transform(\n      code,\n      {\n        babelrc: false,\n        configFile: false,\n        plugins: [removeNonReferencedNodes()],\n      },\n      (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n\n        // keep looping until the code is not changed\n        if (result && result.code! !== code) {\n          return recursiveRemoveNonReferencedNodes(result!.code!).then(resolve, reject);\n        }\n\n        resolve({\n          code: result!.code!,\n          map: result!.map!,\n        });\n      },\n    );\n  });\n}\n","import * as babel from '@babel/core';\nimport { rollup, type RollupOutput } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport commonjs from '@rollup/plugin-commonjs';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { recursiveRemoveNonReferencedNodes } from '../plugins/remove-unused-references';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { removeAllOptionsFromMastraExcept } from '../babel/remove-all-options-except';\nimport json from '@rollup/plugin-json';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\ntype Transformer = (\n  result: { hasCustomConfig: boolean },\n  logger?: IMastraLogger,\n) => ReturnType<typeof removeAllOptionsFromMastraExcept>;\n\nexport function extractMastraOptionBundler(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  result: {\n    hasCustomConfig: false;\n  },\n  logger?: IMastraLogger,\n) {\n  return rollup({\n    logLevel: 'silent',\n    input: {\n      [`${name}-config`]: entryFile,\n    },\n    treeshake: 'smallest',\n    plugins: [\n      tsConfigPaths(),\n      // transpile typescript to something we understand\n      esbuild(),\n      optimizeLodashImports({\n        include: '**/*.{js,ts,mjs,cjs}',\n      }),\n      commonjs({\n        extensions: ['.js', '.ts'],\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      json(),\n      {\n        name: `extract-${name}-config`,\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return new Promise((resolve, reject) => {\n            babel.transform(\n              code,\n              {\n                babelrc: false,\n                configFile: false,\n                filename: id,\n                plugins: [transformer(result, logger)],\n              },\n              (err, result) => {\n                if (err) {\n                  return reject(err);\n                }\n\n                resolve({\n                  code: result!.code!,\n                  map: result!.map!,\n                });\n              },\n            );\n          });\n        },\n      },\n      // let esbuild remove all unused imports\n      esbuild(),\n      {\n        name: 'cleanup',\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return recursiveRemoveNonReferencedNodes(code);\n        },\n      },\n      // let esbuild remove it once more\n      esbuild(),\n    ],\n  });\n}\n\nexport async function extractMastraOption<T>(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<{\n  bundleOutput: RollupOutput;\n  getConfig: () => Promise<T>;\n} | null> {\n  const result = {\n    hasCustomConfig: false,\n  } as const;\n  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);\n\n  const output = await bundler.write({\n    dir: outputDir,\n    format: 'es',\n    entryFileNames: '[name].mjs',\n  });\n\n  if (result.hasCustomConfig) {\n    const configPath = `${outputDir}/${name}-config.mjs`;\n\n    return {\n      bundleOutput: output,\n      getConfig: () => import(`file:${configPath}`).then(m => m[name] as T),\n    };\n  }\n\n  return null;\n}\n","import { removeAllOptionsExceptBundler } from './babel/remove-all-options-bundler';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function getBundlerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('bundler', entryFile, removeAllOptionsExceptBundler, result);\n}\n\nexport async function getBundlerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['bundler'] | null> {\n  const result = await extractMastraOption<Config['bundler']>(\n    'bundler',\n    entryFile,\n    removeAllOptionsExceptBundler,\n    outputDir,\n    logger,\n  );\n\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n","import type { PluginObj } from '@babel/core';\nimport babel from '@babel/core';\n\nexport function checkConfigExport(result: { hasValidConfig: boolean }): PluginObj {\n  const t = babel.types;\n  // Track which local variable names are assigned to `new Mastra()`\n  const mastraVars = new Set<string>();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const decl = path.node.declaration;\n        // 1) export const mastra = new Mastra(...)\n        if (t.isVariableDeclaration(decl)) {\n          const varDecl = decl.declarations[0];\n          if (\n            t.isIdentifier(varDecl?.id, { name: 'mastra' }) &&\n            t.isNewExpression(varDecl.init) &&\n            t.isIdentifier(varDecl.init.callee, { name: 'Mastra' })\n          ) {\n            result.hasValidConfig = true;\n          }\n        }\n        /**\n         * 2) export { foo as mastra }\n         * 3) export { mastra }\n         * 4) export { mastra, foo }\n         */\n        if (Array.isArray(path.node.specifiers)) {\n          for (const spec of path.node.specifiers) {\n            if (\n              t.isExportSpecifier(spec) &&\n              t.isIdentifier(spec.exported, { name: 'mastra' }) &&\n              t.isIdentifier(spec.local) &&\n              mastraVars.has(spec.local.name)\n            ) {\n              result.hasValidConfig = true;\n            }\n          }\n        }\n      },\n      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`\n      VariableDeclaration(path) {\n        for (const decl of path.node.declarations) {\n          if (\n            t.isIdentifier(decl.id) &&\n            t.isNewExpression(decl.init) &&\n            t.isIdentifier(decl.init.callee, { name: 'Mastra' })\n          ) {\n            mastraVars.add(decl.id.name);\n          }\n        }\n      },\n    },\n  };\n}\n","import { join, dirname } from 'node:path';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport slugify from '@sindresorhus/slugify';\nimport * as pkg from 'empathic/package';\nimport { findWorkspaces, findWorkspacesRoot, createWorkspacesCache } from 'find-workspaces';\nimport { ensureDir } from 'fs-extra';\nimport { slash } from '../build/utils';\nimport { DepsService } from '../services';\n\nexport type WorkspacePackageInfo = {\n  location: string;\n  dependencies: Record<string, string> | undefined;\n  version: string | undefined;\n};\n\ntype TransitiveDependencyResult = {\n  resolutions: Record<string, string>;\n  usedWorkspacePackages: Set<string>;\n};\n\n/**\n * Create a shared cache for find-workspaces\n */\nconst workspacesCache = createWorkspacesCache();\n\n/**\n * A utility function around find-workspaces to get information about:\n * - Which workspace packages are available in the project\n * - What is the workspace root location\n * - Is the current package a workspace package\n *\n * Because `findWorkspacesRoot` only traverses up until it finds workspace information, but doesn't check if the current package is even part of the workspace. We rather want to return `null` for these cases because in other code paths we use `workspaceRoot || projectRoot` to determine the root of the project.\n *\n * @params dir - The directory to start searching from (default: `process.cwd()`)\n * @params location - The location of the current package (usually the directory containing the package.json)\n */\nexport async function getWorkspaceInformation({\n  dir = process.cwd(),\n  mastraEntryFile,\n}: {\n  dir?: string;\n  mastraEntryFile: string;\n}) {\n  // 1) Get the location of the current package and its package.json\n  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });\n  const location = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());\n\n  // 2) Get all workspaces\n  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });\n  const _workspaceMap = new Map(\n    workspaces?.map(workspace => [\n      workspace.package.name,\n      {\n        location: workspace.location,\n        dependencies: workspace.package.dependencies,\n        version: workspace.package.version,\n      },\n    ]) ?? [],\n  );\n\n  // 3) Check if the current package is part of the workspace\n  const isWorkspacePackage = (workspaces ?? []).some(ws => ws.location === location);\n\n  // 4) Get the workspace root only if the current package is part of the workspace\n  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : undefined;\n\n  return {\n    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages\n    workspaceMap: isWorkspacePackage ? _workspaceMap : new Map<string, WorkspacePackageInfo>(),\n    workspaceRoot,\n    isWorkspacePackage,\n  };\n}\n\n/**\n * Collects all transitive workspace dependencies and their TGZ paths\n */\nexport const collectTransitiveWorkspaceDependencies = ({\n  workspaceMap,\n  initialDependencies,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  initialDependencies: Set<string>;\n  logger: IMastraLogger;\n}): TransitiveDependencyResult => {\n  const usedWorkspacePackages = new Set<string>();\n  const queue: string[] = Array.from(initialDependencies);\n  const resolutions: Record<string, string> = {};\n\n  while (queue.length > 0) {\n    const len = queue.length;\n    for (let i = 0; i < len; i += 1) {\n      const pkgName = queue.shift();\n      if (!pkgName || usedWorkspacePackages.has(pkgName)) {\n        continue;\n      }\n\n      const dep = workspaceMap.get(pkgName);\n      if (!dep) continue;\n\n      const root = findWorkspacesRoot();\n      if (!root) {\n        throw new Error('Could not find workspace root');\n      }\n\n      const depsService = new DepsService(root.location);\n      depsService.__setLogger(logger);\n      const sanitizedName = slugify(pkgName);\n\n      const tgzPath = depsService.getWorkspaceDependencyPath({\n        pkgName: sanitizedName,\n        version: dep.version!,\n      });\n      resolutions[pkgName] = tgzPath;\n      usedWorkspacePackages.add(pkgName);\n\n      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {\n        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {\n          queue.push(depName);\n        }\n      }\n    }\n  }\n\n  return { resolutions, usedWorkspacePackages };\n};\n\n/**\n * Creates TGZ packages for workspace dependencies in the workspace-module directory\n */\nexport const packWorkspaceDependencies = async ({\n  workspaceMap,\n  usedWorkspacePackages,\n  bundleOutputDir,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  bundleOutputDir: string;\n  logger: IMastraLogger;\n  usedWorkspacePackages: Set<string>;\n}): Promise<void> => {\n  const root = findWorkspacesRoot();\n  if (!root) {\n    throw new Error('Could not find workspace root');\n  }\n\n  const depsService = new DepsService(root.location);\n  depsService.__setLogger(logger);\n\n  // package all workspace dependencies\n  if (usedWorkspacePackages.size > 0) {\n    const workspaceDirPath = join(bundleOutputDir, 'workspace-module');\n    await ensureDir(workspaceDirPath);\n\n    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);\n\n    const batchSize = 5;\n    const packages = Array.from(usedWorkspacePackages.values());\n\n    for (let i = 0; i < packages.length; i += batchSize) {\n      const batch = packages.slice(i, i + batchSize);\n      logger.info(\n        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(', ')}`,\n      );\n      await Promise.all(\n        batch.map(async pkgName => {\n          const dep = workspaceMap.get(pkgName);\n          const sanitizedName = slugify(pkgName);\n          if (!dep) return;\n\n          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName: sanitizedName });\n        }),\n      );\n    }\n\n    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);\n  }\n};\n","import { builtinModules } from 'node:module';\n\nexport function isNodeBuiltin(dep: string): boolean {\n  const [pkg] = dep.split('/');\n\n  return dep.startsWith('node:') || builtinModules.includes(dep) || builtinModules.includes(pkg!);\n}\n","import babel from '@babel/core';\n\nexport function removeDeployer() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-deployer',\n    visitor: {\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        if (!state.hasReplaced) {\n          state.hasReplaced = true;\n          const newMastraObj = t.cloneNode(path.node);\n          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {\n            const deployer = newMastraObj.arguments[0].properties.find(\n              prop => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === 'deployer',\n            );\n\n            if (!deployer) {\n              return;\n            }\n\n            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(\n              prop => prop !== deployer,\n            );\n\n            // try to find the binding of the deployer which should be the reference to the deployer\n            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {\n              const deployerBinding = state.file.scope.getBinding(deployer.value.name);\n\n              if (deployerBinding) {\n                deployerBinding?.path?.parentPath?.remove();\n              }\n            }\n\n            path.replaceWith(newMastraObj);\n          }\n        }\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport type { Plugin } from 'rollup';\n\nimport { removeDeployer as removeDeployerBabelPlugin } from '../babel/remove-deployer';\n\nexport function removeDeployer(mastraEntry: string, options?: { sourcemap?: boolean }): Plugin {\n  return {\n    name: 'remove-deployer',\n    transform(code, id) {\n      if (id !== mastraEntry) {\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        babel.transform(\n          code,\n          {\n            babelrc: false,\n            configFile: false,\n            filename: id,\n            plugins: [removeDeployerBabelPlugin],\n            sourceMaps: options?.sourcemap,\n          },\n          (err, result) => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve({\n              code: result!.code!,\n              map: result!.map!,\n            });\n          },\n        );\n      });\n    },\n  } satisfies Plugin;\n}\n","export const DEPS_TO_IGNORE = ['#tools'];\n\nexport const GLOBAL_EXTERNALS = [\n  'pino',\n  'pino-pretty',\n  '@libsql/client',\n  'pg',\n  'libsql',\n  '#tools',\n  'typescript',\n  'undici',\n  'readable-stream',\n];\nexport const DEPRECATED_EXTERNALS = ['fastembed', 'nodemailer', 'jsdom', 'sqlite3'];\n","import { noopLogger, type IMastraLogger } from '@mastra/core/logger';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport virtual from '@rollup/plugin-virtual';\nimport { fileURLToPath } from 'node:url';\nimport { rollup, type OutputChunk, type Plugin, type SourceMap } from 'rollup';\nimport resolveFrom from 'resolve-from';\nimport { esbuild } from '../plugins/esbuild';\nimport { isNodeBuiltin } from '../isNodeBuiltin';\nimport { removeDeployer } from '../plugins/remove-deployer';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { getPackageName, getPackageRootPath, slash } from '../utils';\nimport { type WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from '../types';\nimport { DEPS_TO_IGNORE } from './constants';\n\n/**\n * Configures and returns the Rollup plugins needed for analyzing entry files.\n * Sets up module resolution, transpilation, and custom alias handling for Mastra-specific imports.\n */\nfunction getInputPlugins(\n  { entry, isVirtualFile }: { entry: string; isVirtualFile: boolean },\n  mastraEntry: string,\n  { sourcemapEnabled }: { sourcemapEnabled: boolean },\n): Plugin[] {\n  const normalizedMastraEntry = slash(mastraEntry);\n  let virtualPlugin = null;\n  if (isVirtualFile) {\n    virtualPlugin = virtual({\n      '#entry': entry,\n    });\n    entry = '#entry';\n  }\n\n  const plugins = [];\n  if (virtualPlugin) {\n    plugins.push(virtualPlugin);\n  }\n\n  plugins.push(\n    ...[\n      tsConfigPaths(),\n      {\n        name: 'custom-alias-resolver',\n        resolveId(id: string) {\n          if (id === '#server') {\n            return slash(fileURLToPath(import.meta.resolve('@mastra/deployer/server')));\n          }\n          if (id === '#mastra') {\n            return normalizedMastraEntry;\n          }\n          if (id.startsWith('@mastra/server')) {\n            return fileURLToPath(import.meta.resolve(id));\n          }\n        },\n      } satisfies Plugin,\n      json(),\n      esbuild(),\n      commonjs({\n        strictRequires: 'debug',\n        ignoreTryCatch: false,\n        transformMixedEsModules: true,\n        extensions: ['.js', '.ts'],\n      }),\n      removeDeployer(mastraEntry, { sourcemap: sourcemapEnabled }),\n      esbuild(),\n    ],\n  );\n\n  return plugins;\n}\n\n/**\n * Extracts and categorizes dependencies from Rollup output to determine which ones need optimization.\n * Analyzes both static imports and dynamic imports while filtering out Node.js built-ins and ignored dependencies.\n * Identifies workspace packages and resolves package root paths for proper bundling optimization.\n */\nasync function captureDependenciesToOptimize(\n  output: OutputChunk,\n  workspaceMap: Map<string, WorkspacePackageInfo>,\n  projectRoot: string,\n  initialDepsToOptimize: Map<string, DependencyMetadata>,\n  {\n    logger,\n    shouldCheckTransitiveDependencies,\n  }: {\n    logger: IMastraLogger;\n    shouldCheckTransitiveDependencies: boolean;\n  },\n): Promise<Map<string, DependencyMetadata>> {\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  if (!output.facadeModuleId) {\n    throw new Error(\n      'Something went wrong, we could not find the package name of the entry file. Please open an issue.',\n    );\n  }\n\n  let entryRootPath = projectRoot;\n  if (!output.facadeModuleId.startsWith('\\x00virtual:')) {\n    entryRootPath = (await getPackageRootPath(output.facadeModuleId)) || projectRoot;\n  }\n\n  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {\n    if (isNodeBuiltin(dependency) || dependency.startsWith('#')) {\n      continue;\n    }\n\n    // The `getPackageName` helper also handles subpaths so we only get the proper package name\n    const pkgName = getPackageName(dependency);\n    let rootPath: string | null = null;\n    let isWorkspace = false;\n\n    if (pkgName) {\n      rootPath = await getPackageRootPath(dependency, entryRootPath);\n      isWorkspace = workspaceMap.has(pkgName);\n    }\n\n    const normalizedRootPath = rootPath ? slash(rootPath) : null;\n\n    depsToOptimize.set(dependency, {\n      exports: bindings,\n      rootPath: normalizedRootPath,\n      isWorkspace,\n    });\n  }\n\n  /**\n   * Recursively discovers and analyzes transitive workspace dependencies\n   */\n  async function checkTransitiveDependencies(\n    internalMap: Map<string, DependencyMetadata>,\n    maxDepth = 10,\n    currentDepth = 0,\n  ) {\n    // Could be a circular dependency...\n    if (currentDepth >= maxDepth) {\n      logger.warn('Maximum dependency depth reached while checking transitive dependencies.');\n      return;\n    }\n\n    // Make a copy so that we can safely iterate over it\n    const depsSnapshot = new Map(depsToOptimize);\n    let hasAddedDeps = false;\n\n    for (const [dep, meta] of depsSnapshot) {\n      // We only care about workspace deps that we haven't already processed\n      if (!meta.isWorkspace || internalMap.has(dep)) {\n        continue;\n      }\n\n      try {\n        // Absolute path to the dependency\n        const resolvedPath = resolveFrom(projectRoot, dep);\n        if (!resolvedPath) {\n          logger.warn(`Could not resolve path for workspace dependency ${dep}`);\n          continue;\n        }\n\n        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, '', {\n          workspaceMap,\n          projectRoot,\n          logger: noopLogger,\n          sourcemapEnabled: false,\n          initialDepsToOptimize: depsToOptimize,\n        });\n\n        if (!analysis?.dependencies) {\n          continue;\n        }\n\n        for (const [innerDep, innerMeta] of analysis.dependencies) {\n          /**\n           * Only add to depsToOptimize if:\n           * - It's a workspace package\n           * - We haven't already processed it\n           * - We haven't already discovered it at the beginning\n           */\n          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {\n            depsToOptimize.set(innerDep, innerMeta);\n            internalMap.set(innerDep, innerMeta);\n            hasAddedDeps = true;\n          }\n        }\n      } catch (err) {\n        logger.error(`Failed to resolve or analyze dependency ${dep}: ${(err as Error).message}`);\n      }\n    }\n\n    // Continue until no new deps are found\n    if (hasAddedDeps) {\n      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);\n    }\n  }\n\n  if (shouldCheckTransitiveDependencies) {\n    await checkTransitiveDependencies(initialDepsToOptimize);\n  }\n\n  // #tools is a generated dependency, we don't want our analyzer to handle it\n  const dynamicImports = output.dynamicImports.filter(d => !DEPS_TO_IGNORE.includes(d));\n  if (dynamicImports.length) {\n    for (const dynamicImport of dynamicImports) {\n      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {\n        depsToOptimize.set(dynamicImport, {\n          exports: ['*'],\n          rootPath: null,\n          isWorkspace: false,\n        });\n      }\n    }\n  }\n\n  return depsToOptimize;\n}\n\n/**\n * Analyzes the entry file to identify external dependencies and their imports. This allows us to treeshake all code that is not used.\n *\n * @param entryConfig - Configuration object for the entry file\n * @param entryConfig.entry - The entry file path or content\n * @param entryConfig.isVirtualFile - Whether the entry is a virtual file (content string) or a file path\n * @param mastraEntry - The mastra entry point\n * @param options - Configuration options for the analysis\n * @param options.logger - Logger instance for debugging\n * @param options.sourcemapEnabled - Whether sourcemaps are enabled\n * @param options.workspaceMap - Map of workspace packages\n * @param options.shouldCheckTransitiveDependencies - Whether to recursively analyze transitive workspace dependencies (default: false)\n * @returns A promise that resolves to an object containing the analyzed dependencies and generated output\n */\nexport async function analyzeEntry(\n  {\n    entry,\n    isVirtualFile,\n  }: {\n    entry: string;\n    isVirtualFile: boolean;\n  },\n  mastraEntry: string,\n  {\n    logger,\n    sourcemapEnabled,\n    workspaceMap,\n    projectRoot,\n    initialDepsToOptimize = new Map(), // used to avoid infinite recursion\n    shouldCheckTransitiveDependencies = false,\n  }: {\n    logger: IMastraLogger;\n    sourcemapEnabled: boolean;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    projectRoot: string;\n    initialDepsToOptimize?: Map<string, DependencyMetadata>;\n    shouldCheckTransitiveDependencies?: boolean;\n  },\n): Promise<{\n  dependencies: Map<string, DependencyMetadata>;\n  output: {\n    code: string;\n    map: SourceMap | null;\n  };\n}> {\n  const optimizerBundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: isVirtualFile ? '#entry' : entry,\n    treeshake: false,\n    preserveSymlinks: true,\n    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),\n    external: DEPS_TO_IGNORE,\n  });\n\n  const { output } = await optimizerBundler.generate({\n    format: 'esm',\n    inlineDynamicImports: true,\n  });\n\n  await optimizerBundler.close();\n\n  const depsToOptimize = await captureDependenciesToOptimize(\n    output[0] as OutputChunk,\n    workspaceMap,\n    projectRoot,\n    initialDepsToOptimize,\n    {\n      logger,\n      shouldCheckTransitiveDependencies,\n    },\n  );\n\n  return {\n    dependencies: depsToOptimize,\n    output: {\n      code: output[0].code,\n      map: output[0].map as SourceMap,\n    },\n  };\n}\n","import originalEsmShim from '@rollup/plugin-esm-shim';\nimport type { Plugin } from 'rollup';\n\n// Regex to detect DECLARATIONS of __filename, __dirname\n// Using non-capturing group (?:) for slightly better performance\nconst FilenameDeclarationRegex = /(?:const|let|var)\\s+__filename/;\nconst DirnameDeclarationRegex = /(?:const|let|var)\\s+__dirname/;\n\n/**\n * Custom ESM shim plugin wrapper that respects user-declared __filename/__dirname variables.\n *\n * The original @rollup/plugin-esm-shim would inject shims even when users had already declared\n * their own __filename/__dirname, causing \"Identifier '__filename' has already been declared\" errors.\n *\n * This wrapper checks if the user has already declared these variables and skips the shim injection\n * if so. If either variable is declared, we skip the shim entirely since the original plugin injects\n * both together and we assume users who declare one will also handle the other if needed.\n */\nexport function esmShim(): Plugin {\n  const original = originalEsmShim();\n\n  return {\n    name: 'esm-shim',\n    renderChunk(code, chunk, opts, meta) {\n      // Fast path: use includes() first to avoid regex if identifiers aren't present\n      const hasFilename = code.includes('__filename');\n      const hasDirname = code.includes('__dirname');\n\n      // If user declared either __filename or __dirname, skip shim injection entirely\n      // since the original plugin injects both together\n      const userDeclaredFilename = hasFilename && FilenameDeclarationRegex.test(code);\n      const userDeclaredDirname = hasDirname && DirnameDeclarationRegex.test(code);\n\n      if (userDeclaredFilename || userDeclaredDirname) {\n        return null;\n      }\n\n      // Otherwise, delegate to the original plugin\n      if (typeof original.renderChunk === 'function') {\n        return original.renderChunk.call(this, code, chunk, opts, meta);\n      }\n\n      return null;\n    },\n  };\n}\n\nexport default esmShim;\n","import { fileURLToPath } from 'node:url';\nimport type { Plugin } from 'rollup';\n\n// hono is imported from deployer, so we need to resolve from here instead of the project root\nexport function aliasHono(): Plugin {\n  return {\n    name: 'hono-alias',\n    resolveId(id: string) {\n      if (!id.startsWith('@hono/') && !id.startsWith('hono/') && id !== 'hono' && id !== 'hono-openapi') {\n        return;\n      }\n\n      const path = import.meta.resolve(id);\n      return fileURLToPath(path);\n    },\n  } satisfies Plugin;\n}\n","import type { Plugin } from 'rollup';\nimport { isDependencyPartOfPackage } from '../utils';\n\nexport function subpathExternalsResolver(externals: string[]): Plugin {\n  return {\n    name: 'subpath-externals-resolver',\n    resolveId(id) {\n      if (id.startsWith('.') || id.startsWith('/')) {\n        return null;\n      }\n\n      const isPartOfExternals = externals.some(external => isDependencyPartOfPackage(id, external));\n      if (isPartOfExternals) {\n        return {\n          id,\n          external: true,\n        };\n      }\n    },\n  } satisfies Plugin;\n}\n","import type { Plugin } from 'rollup';\nimport { getPackageInfo } from 'local-pkg';\n\nexport function nodeGypDetector(): Plugin {\n  const modulesToTrack = new Set<string>();\n  const modulesToTrackPackageInfo = new Map<string, ReturnType<typeof getPackageInfo>>();\n\n  return {\n    name: 'node-gyp-build-detector',\n    moduleParsed(info) {\n      if (!info.meta?.commonjs?.requires?.length) {\n        return;\n      }\n\n      const hasNodeGypBuild = info.meta.commonjs.requires.some((m: { resolved?: { id: string } }) =>\n        m?.resolved?.id.endsWith('node-gyp-build/index.js'),\n      );\n      if (!hasNodeGypBuild) {\n        return;\n      }\n\n      modulesToTrack.add(info.id);\n      modulesToTrackPackageInfo.set(info.id, getPackageInfo(info.id));\n    },\n\n    async generateBundle(options, bundle) {\n      const binaryMapByChunk = new Map<string, Set<string>>();\n      // Iterate through all output chunks\n      for (const [fileName, chunk] of Object.entries(bundle)) {\n        // Only chunks have modules, assets don't\n        if (chunk.type === 'chunk') {\n          for (const moduleId of chunk.moduleIds) {\n            if (modulesToTrackPackageInfo.has(moduleId)) {\n              const pkgInfo = await modulesToTrackPackageInfo.get(moduleId)!;\n\n              if (!binaryMapByChunk.has(fileName)) {\n                binaryMapByChunk.set(fileName, new Set());\n              }\n\n              if (pkgInfo?.packageJson?.name) {\n                binaryMapByChunk.get(fileName)!.add(pkgInfo.packageJson.name);\n              }\n            }\n          }\n        }\n      }\n\n      const binaryMapJson = Object.fromEntries(\n        Array.from(binaryMapByChunk.entries()).map(([key, value]) => [key, Array.from(value)]),\n      );\n\n      // store all binaries used by a module to show in the error message\n      this.emitFile({\n        type: 'asset',\n        name: 'binary-map.json',\n        source: `${JSON.stringify(binaryMapJson, null, 2)}`,\n      });\n    },\n  } satisfies Plugin;\n}\n","import type { Plugin } from 'rollup';\nimport { isDependencyPartOfPackage, slash } from '../utils';\nimport { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\nexport function moduleResolveMap(externals: string[], projectRoot: string): Plugin {\n  const importMap = new Map<string, string>();\n  return {\n    name: 'module-resolve-map',\n    moduleParsed(info) {\n      if (info.importedIds.length === 0 || !info.id) {\n        return;\n      }\n\n      for (const importedId of info.importedIds) {\n        for (const external of externals) {\n          if (isDependencyPartOfPackage(importedId, external)) {\n            // TODO add multi version support\n            importMap.set(external, info.id);\n          }\n        }\n      }\n    },\n\n    async generateBundle(options, bundle) {\n      const resolveMap = new Map<string, Map<string, string>>();\n\n      // Iterate through all output chunks\n      for (const [fileName, chunk] of Object.entries(bundle)) {\n        // Only chunks have modules, assets don't\n        if (chunk.type === 'chunk') {\n          for (const [external, resolvedFrom] of importMap) {\n            if (chunk.moduleIds.includes(resolvedFrom)) {\n              const fullPath = pathToFileURL(slash(join(projectRoot, fileName))).toString();\n              const innerMap = resolveMap.get(fullPath) || new Map<string, string>();\n              innerMap.set(external, pathToFileURL(slash(resolvedFrom)).toString());\n              resolveMap.set(fullPath, innerMap);\n            }\n          }\n        }\n      }\n\n      // store all binaries used by a module to show in the error message\n      const resolveMapJson = Object.fromEntries(\n        Array.from(resolveMap.entries()).map(([key, value]) => [key, Object.fromEntries(value.entries())]),\n      );\n\n      this.emitFile({\n        type: 'asset',\n        name: 'module-resolve-map.json',\n        source: `${JSON.stringify(resolveMapJson, null, 2)}`,\n      });\n    },\n  } satisfies Plugin;\n}\n","import commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport virtual from '@rollup/plugin-virtual';\nimport { esmShim } from '../plugins/esm-shim';\nimport { basename } from 'node:path/posix';\nimport * as path from 'node:path';\nimport { rollup, type OutputChunk, type OutputAsset, type Plugin } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport { aliasHono } from '../plugins/hono-alias';\nimport {\n  getCompiledDepCachePath,\n  getPackageRootPath,\n  isDependencyPartOfPackage,\n  rollupSafeName,\n  slash,\n} from '../utils';\nimport { type WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from '../types';\nimport { DEPS_TO_IGNORE, GLOBAL_EXTERNALS, DEPRECATED_EXTERNALS } from './constants';\nimport * as resolve from 'resolve.exports';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { readFile } from 'node:fs/promises';\nimport { getPackageInfo } from 'local-pkg';\nimport { ErrorCategory, ErrorDomain, MastraBaseError } from '@mastra/core/error';\nimport { subpathExternalsResolver } from '../plugins/subpath-externals-resolver';\nimport { nodeGypDetector } from '../plugins/node-gyp-detector';\nimport { moduleResolveMap } from '../plugins/module-resolve-map';\n\ntype VirtualDependency = {\n  name: string;\n  virtual: string;\n};\n\nfunction prepareEntryFileName(name: string, rootDir: string) {\n  return rollupSafeName(name, rootDir);\n}\n\n/**\n * Creates virtual dependency modules for optimized bundling by generating virtual entry points for each dependency with their specific exports and handling workspace package path resolution.\n */\nexport function createVirtualDependencies(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  {\n    projectRoot,\n    workspaceRoot,\n    outputDir,\n    bundlerOptions,\n  }: { workspaceRoot: string | null; projectRoot: string; outputDir: string; bundlerOptions?: { isDev?: boolean } },\n): {\n  optimizedDependencyEntries: Map<string, VirtualDependency>;\n  fileNameToDependencyMap: Map<string, string>;\n} {\n  const { isDev = false } = bundlerOptions || {};\n  const fileNameToDependencyMap = new Map<string, string>();\n  const optimizedDependencyEntries = new Map<string, VirtualDependency>();\n  const rootDir = workspaceRoot || projectRoot;\n\n  for (const [dep, { exports }] of depsToOptimize.entries()) {\n    const fileName = dep.replaceAll('/', '-');\n    const virtualFile: string[] = [];\n    const exportStringBuilder = [];\n\n    for (const local of exports) {\n      if (local === '*') {\n        virtualFile.push(`export * from '${dep}';`);\n        continue;\n      } else if (local === 'default') {\n        exportStringBuilder.push('default');\n      } else {\n        exportStringBuilder.push(local);\n      }\n    }\n\n    const chunks = [];\n    if (exportStringBuilder.length) {\n      chunks.push(`{ ${exportStringBuilder.join(', ')} }`);\n    }\n    if (chunks.length) {\n      virtualFile.push(`export ${chunks.join(', ')} from '${dep}';`);\n    }\n\n    // Determine the entry name based on the complexity of exports\n    let entryName = prepareEntryFileName(path.join(outputDir, fileName), rootDir);\n\n    fileNameToDependencyMap.set(entryName, dep);\n    optimizedDependencyEntries.set(dep, {\n      name: entryName,\n      virtual: virtualFile.join('\\n'),\n    });\n  }\n\n  // For workspace packages, we still want the dependencies to be imported from the original path\n  // We rewrite the path to the original folder inside node_modules/.cache\n  if (isDev) {\n    for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {\n      if (!isWorkspace || !rootPath || !workspaceRoot) {\n        continue;\n      }\n\n      const currentDepPath = optimizedDependencyEntries.get(dep);\n      if (!currentDepPath) {\n        continue;\n      }\n\n      const fileName = basename(currentDepPath.name);\n      const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);\n\n      fileNameToDependencyMap.set(entryName, dep);\n      optimizedDependencyEntries.set(dep, {\n        ...currentDepPath,\n        name: entryName,\n      });\n    }\n  }\n\n  return { optimizedDependencyEntries, fileNameToDependencyMap };\n}\n\n/**\n * Configures and returns Rollup plugins for bundling external dependencies.\n * Sets up virtual modules, TypeScript compilation, CommonJS transformation, and workspace resolution.\n */\nasync function getInputPlugins(\n  virtualDependencies: Map<string, { name: string; virtual: string }>,\n  {\n    transpilePackages,\n    workspaceMap,\n    bundlerOptions,\n    rootDir,\n    externals,\n  }: {\n    transpilePackages: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    bundlerOptions: { enableEsmShim: boolean; isDev: boolean };\n    rootDir: string;\n    externals: string[];\n  },\n) {\n  const transpilePackagesMap = new Map<string, string>();\n  for (const pkg of transpilePackages) {\n    const dir = await getPackageRootPath(pkg);\n\n    if (dir) {\n      transpilePackagesMap.set(pkg, slash(dir));\n    } else {\n      transpilePackagesMap.set(pkg, workspaceMap.get(pkg)?.location ?? pkg);\n    }\n  }\n\n  return [\n    virtual(\n      Array.from(virtualDependencies.entries()).reduce(\n        (acc, [dep, virtualDep]) => {\n          acc[`#virtual-${dep}`] = virtualDep.virtual;\n          return acc;\n        },\n        {} as Record<string, string>,\n      ),\n    ),\n    subpathExternalsResolver(externals),\n    transpilePackagesMap.size\n      ? esbuild({\n          format: 'esm',\n          include: [...transpilePackagesMap.values()].map(p => {\n            // Match files from transpilePackages but exclude any nested node_modules\n            // Escapes regex special characters in the path and uses negative lookahead to avoid node_modules\n            // generated by cursor\n            if (path.isAbsolute(p)) {\n              return new RegExp(`^${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            } else {\n              return new RegExp(`\\/${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            }\n          }),\n        })\n      : null,\n    bundlerOptions.isDev\n      ? ({\n          name: 'alias-optimized-deps',\n          async resolveId(id, importer, options) {\n            if (!virtualDependencies.has(id)) {\n              return null;\n            }\n\n            const info = virtualDependencies.get(id)!;\n            // go from ./node_modules/.cache/index.js to ./pkg\n            const packageRootPath = path.join(rootDir, path.dirname(path.dirname(path.dirname(info.name))));\n            const pkgJsonBuffer = await readFile(path.join(packageRootPath, 'package.json'), 'utf-8');\n            const pkgJson = JSON.parse(pkgJsonBuffer);\n            if (!pkgJson) {\n              return null;\n            }\n\n            const pkgName = pkgJson.name || '';\n            let resolvedPath: string | undefined = resolve.exports(pkgJson, id.replace(pkgName, '.'))?.[0];\n            if (!resolvedPath) {\n              resolvedPath = pkgJson!.main ?? 'index.js';\n            }\n\n            const resolved = await this.resolve(path.posix.join(packageRootPath, resolvedPath!), importer, options);\n            return resolved;\n          },\n        } satisfies Plugin)\n      : null,\n    optimizeLodashImports({\n      include: '**/*.{js,ts,mjs,cjs}',\n    }),\n    commonjs({\n      strictRequires: 'strict',\n      transformMixedEsModules: true,\n      ignoreTryCatch: false,\n    }),\n    bundlerOptions.isDev\n      ? null\n      : nodeResolve({\n          preferBuiltins: true,\n          exportConditions: ['node'],\n        }),\n    bundlerOptions.isDev ? esmShim() : null,\n    // hono is imported from deployer, so we need to resolve from here instead of the project root\n    aliasHono(),\n    json(),\n    nodeGypDetector(),\n    moduleResolveMap(externals, rootDir),\n    {\n      name: 'not-found-resolver',\n      resolveId: {\n        order: 'post',\n        async handler(id, importer) {\n          if (!importer) {\n            return null;\n          }\n\n          if (!id.endsWith('.node')) {\n            return null;\n          }\n\n          const pkgInfo = await getPackageInfo(importer);\n          const packageName = pkgInfo?.packageJson?.name || id;\n          throw new MastraBaseError({\n            id: 'DEPLOYER_BUNDLE_EXTERNALS_MISSING_NATIVE_BUILD',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              importFile: importer,\n              packageName,\n            },\n            text: `We found a possible binary dependency in your bundle. ${id} was not found when imported at ${importer}.\n            \nPlease consider adding \\`${packageName}\\` to your externals, or updating this import to not end with \".node\".\n  \nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n          });\n        },\n      },\n    } satisfies Plugin,\n  ].filter(Boolean);\n}\n\n/**\n * Executes the Rollup build process for virtual dependencies using configured plugins.\n * Bundles all virtual dependency modules into optimized ESM files with proper external handling.\n */\nasync function buildExternalDependencies(\n  virtualDependencies: Map<string, VirtualDependency>,\n  {\n    externals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir,\n    outputDir,\n    bundlerOptions,\n  }: {\n    externals: string[];\n    packagesToTranspile: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    rootDir: string;\n    outputDir: string;\n    bundlerOptions: {\n      enableEsmShim: boolean;\n      isDev: boolean;\n    };\n  },\n) {\n  /**\n   * If there are no virtual dependencies to bundle, return an empty array to avoid Rollup errors.\n   */\n  if (virtualDependencies.size === 0) {\n    return [] as unknown as [OutputChunk, ...(OutputAsset | OutputChunk)[]];\n  }\n\n  const bundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: Array.from(virtualDependencies.entries()).reduce(\n      (acc, [dep, virtualDep]) => {\n        acc[virtualDep.name] = `#virtual-${dep}`;\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n    external: externals,\n    treeshake: bundlerOptions.isDev ? false : 'safest',\n    plugins: getInputPlugins(virtualDependencies, {\n      transpilePackages: packagesToTranspile,\n      workspaceMap,\n      bundlerOptions,\n      rootDir,\n      externals,\n    }),\n  });\n\n  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);\n\n  const { output } = await bundler.write({\n    format: 'esm',\n    dir: rootDir,\n    entryFileNames: '[name].mjs',\n    // used to get the filename of the actual error\n    sourcemap: true,\n    /**\n     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.\n     * So we want to write them to the `.mastra/output` folder as well.\n     */\n    chunkFileNames: chunkInfo => {\n      /**\n       * This whole bunch of logic directly below is for the edge case shown in the e2e-tests/monorepo with \"tinyrainbow\" package. It's used in multiple places in the package and as such Rollup creates a shared chunk for it. During 'mastra dev', we don't want that chunk to show up in the '.mastra/output' folder (outputDirRelative) but inside <pkg>/node_modules/.cache instead.\n       * We only care about this during 'mastra dev'!\n       */\n      if (bundlerOptions.isDev) {\n        const importedFromPackages = new Set<string>();\n\n        for (const moduleId of chunkInfo.moduleIds) {\n          const normalized = slash(moduleId);\n          for (const [pkgName, pkgInfo] of workspaceMap.entries()) {\n            const location = slash(pkgInfo.location);\n            if (normalized.startsWith(location)) {\n              importedFromPackages.add(pkgName);\n              break;\n            }\n          }\n        }\n\n        if (importedFromPackages.size > 1) {\n          throw new MastraBaseError({\n            id: 'DEPLOYER_BUNDLE_EXTERNALS_SHARED_CHUNK',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              chunkName: chunkInfo.name,\n              packages: JSON.stringify(Array.from(importedFromPackages)),\n            },\n            text: `Please open an issue. We found a shared chunk \"${chunkInfo.name}\" used by multiple workspace packages: ${Array.from(importedFromPackages).join(', ')}.`,\n          });\n        }\n\n        if (importedFromPackages.size === 1) {\n          const [pkgName] = importedFromPackages;\n          const workspaceLocation = workspaceMap.get(pkgName!)!.location;\n          return prepareEntryFileName(getCompiledDepCachePath(workspaceLocation, '[name].mjs'), rootDir);\n        }\n      }\n\n      return `${outputDirRelative}/[name].mjs`;\n    },\n    assetFileNames: `${outputDirRelative}/[name][extname]`,\n    hoistTransitiveImports: false,\n  });\n\n  await bundler.close();\n\n  return output;\n}\n\n/**\n * Recursively searches through Rollup output chunks to find which module imports a specific external dependency.\n * Used to build the module resolution map for proper external dependency tracking.\n */\nfunction findExternalImporter(module: OutputChunk, external: string, allOutputs: OutputChunk[]): OutputChunk | null {\n  const capturedFiles = new Set();\n\n  for (const id of module.imports) {\n    if (isDependencyPartOfPackage(id, external)) {\n      return module;\n    } else {\n      if (id.endsWith('.mjs')) {\n        capturedFiles.add(id);\n      }\n    }\n  }\n\n  for (const file of capturedFiles) {\n    const nextModule = allOutputs.find(o => o.fileName === file);\n    if (nextModule) {\n      const importer = findExternalImporter(nextModule, external, allOutputs);\n\n      if (importer) {\n        return importer;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Bundles vendor dependencies identified in the analysis step.\n * Creates virtual modules for each dependency and bundles them using rollup.\n *\n * @param depsToOptimize - Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)\n * @param outputDir - Directory where bundled files will be written\n * @param logger - Logger instance for debugging\n * @returns Object containing bundle output and reference map for validation\n */\nexport async function bundleExternals(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  outputDir: string,\n  options: {\n    bundlerOptions?: {\n      externals?: string[];\n      transpilePackages?: string[];\n      isDev?: boolean;\n      enableEsmShim?: boolean;\n    } | null;\n    projectRoot?: string;\n    workspaceRoot?: string;\n    workspaceMap?: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  const { workspaceRoot = null, workspaceMap = new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;\n  const {\n    externals: customExternals = [],\n    transpilePackages = [],\n    isDev = false,\n    enableEsmShim = true,\n  } = bundlerOptions || {};\n  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...customExternals];\n\n  const workspacePackagesNames = Array.from(workspaceMap.keys());\n  const packagesToTranspile = new Set([...transpilePackages, ...workspacePackagesNames]);\n\n  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {\n    workspaceRoot,\n    outputDir,\n    projectRoot,\n    bundlerOptions: {\n      isDev,\n    },\n  });\n\n  const output = await buildExternalDependencies(optimizedDependencyEntries, {\n    externals: allExternals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir: workspaceRoot || projectRoot,\n    outputDir,\n    bundlerOptions: {\n      enableEsmShim,\n      isDev,\n    },\n  });\n\n  const moduleResolveMap = new Map<string, Map<string, string>>();\n  const filteredChunks = output.filter(o => o.type === 'chunk');\n\n  for (const o of filteredChunks.filter(o => o.isEntry || o.isDynamicEntry)) {\n    for (const external of allExternals) {\n      if (DEPS_TO_IGNORE.includes(external)) {\n        continue;\n      }\n\n      const importer = findExternalImporter(o, external, filteredChunks);\n\n      if (importer) {\n        const fullPath = path.join(workspaceRoot || projectRoot, importer.fileName);\n        let innerMap = moduleResolveMap.get(fullPath);\n\n        if (!innerMap) {\n          innerMap = new Map<string, string>();\n          moduleResolveMap.set(fullPath, innerMap);\n        }\n\n        if (importer.moduleIds.length) {\n          innerMap.set(\n            external,\n            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith('\\x00virtual:#virtual')\n              ? importer.moduleIds[importer.moduleIds.length - 2]!\n              : importer.moduleIds[importer.moduleIds.length - 1]!,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert moduleResolveMap to a plain object with prototype-less objects\n   */\n  const usedExternals = Object.create(null) as Record<string, Record<string, string>>;\n  for (const [fullPath, innerMap] of moduleResolveMap) {\n    const innerObj = Object.create(null) as Record<string, string>;\n    for (const [external, value] of innerMap) {\n      innerObj[external] = value;\n    }\n    usedExternals[fullPath] = innerObj;\n  }\n\n  return { output, fileNameToDependencyMap, usedExternals };\n}\n","var UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nexport { parse };\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport * as babel from '@babel/core';\nimport { existsSync } from 'node:fs';\nimport { readFile, writeFile } from 'node:fs/promises';\nimport type { OutputAsset, OutputChunk } from 'rollup';\nimport { basename, join, parse } from 'node:path';\nimport { validate, ValidationError } from '../validator/validate';\nimport { getBundlerOptions } from './bundlerOptions';\nimport { checkConfigExport } from './babel/check-config-export';\nimport { getWorkspaceInformation, type WorkspacePackageInfo } from '../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from './types';\nimport { analyzeEntry } from './analyze/analyzeEntry';\nimport { bundleExternals } from './analyze/bundleExternals';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { isDependencyPartOfPackage } from './utils';\nimport { GLOBAL_EXTERNALS } from './analyze/constants';\nimport * as stackTraceParser from 'stacktrace-parser';\n\ntype ErrorId =\n  | 'DEPLOYER_ANALYZE_MODULE_NOT_FOUND'\n  | 'DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD'\n  | 'DEPLOYER_ANALYZE_TYPE_ERROR';\n\nfunction throwExternalDependencyError({\n  errorId,\n  moduleName,\n  packageName,\n  messagePrefix,\n}: {\n  errorId: ErrorId;\n  moduleName: string;\n  packageName: string;\n  messagePrefix: string;\n}): never {\n  throw new MastraError({\n    id: errorId,\n    domain: ErrorDomain.DEPLOYER,\n    category: ErrorCategory.USER,\n    details: {\n      importFile: moduleName,\n      packageName: packageName,\n    },\n    text: `${messagePrefix} \\`${packageName}\\` to your externals.\n\nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n  });\n}\n\nfunction getPackageNameFromBundledModuleName(moduleName: string) {\n  const chunks = moduleName.split('-');\n\n  if (!chunks.length) {\n    return moduleName;\n  }\n\n  if (chunks[0]?.startsWith('@')) {\n    return chunks.slice(0, 2).join('/');\n  }\n\n  return chunks[0];\n}\n\nfunction validateError(\n  err: ValidationError | Error,\n  file: OutputChunk,\n  {\n    binaryMapData,\n    workspaceMap,\n  }: {\n    binaryMapData: Record<string, string[]>;\n    logger: IMastraLogger;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  let moduleName: string | undefined | null = null;\n  let errorConfig: {\n    id: ErrorId;\n    messagePrefix: string;\n  } | null = null;\n\n  if (err instanceof ValidationError) {\n    const parsedStack = stackTraceParser.parse(err.stack);\n    if (err.type === 'TypeError') {\n      const pkgNameRegex = /.*node_modules\\/([^\\/]+)\\//;\n      const stacktraceFrame = parsedStack.find(frame => frame.file && pkgNameRegex.test(frame.file));\n      if (stacktraceFrame) {\n        const match = stacktraceFrame.file!.match(pkgNameRegex);\n        moduleName = match?.[1] ?? getPackageNameFromBundledModuleName(basename(file.name));\n      } else {\n        moduleName = getPackageNameFromBundledModuleName(basename(file.name));\n      }\n\n      errorConfig = {\n        id: 'DEPLOYER_ANALYZE_TYPE_ERROR',\n        messagePrefix: `Mastra wasn't able to bundle \"${moduleName}\", might be an older commonJS module. Please add`,\n      };\n    } else if (err.stack?.includes?.('[ERR_MODULE_NOT_FOUND]')) {\n      moduleName = err.message.match(/Cannot find package '([^']+)'/)?.[1];\n\n      const parentModuleName = getPackageNameFromBundledModuleName(basename(file.name));\n\n      errorConfig = {\n        id: 'DEPLOYER_ANALYZE_MODULE_NOT_FOUND',\n        messagePrefix: `Mastra wasn't able to build your project, We couldn't load \"${moduleName}\" from \"${parentModuleName}\". Make sure \"${moduleName}\" is installed or add`,\n      };\n\n      // if they are the same, the feedback we give to our user is not really useful and probably something else went wrong\n      if (moduleName === parentModuleName) {\n        return;\n      }\n    }\n  }\n\n  if (err.message.includes('No native build was found')) {\n    const pkgName = getPackageNameFromBundledModuleName(basename(file.name));\n    moduleName = binaryMapData[file.fileName]?.[0] ?? pkgName;\n    errorConfig = {\n      id: 'DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD',\n      messagePrefix: 'We found a binary dependency in your bundle but we cannot bundle it yet. Please add',\n    };\n  }\n\n  if (moduleName && workspaceMap.has(moduleName)) {\n    throw new MastraError({\n      id: 'DEPLOYER_ANALYZE_ERROR_IN_WORKSPACE',\n      domain: ErrorDomain.DEPLOYER,\n      category: ErrorCategory.USER,\n      details: {\n        // importFile: moduleName,\n        packageName: moduleName,\n      },\n      text: `We found an error in the ${moduleName} workspace package. Please find the offending package and fix the error.\n  Error: ${err.stack}`,\n    });\n  }\n\n  if (errorConfig && moduleName) {\n    throwExternalDependencyError({\n      errorId: errorConfig.id,\n      moduleName: moduleName!,\n      packageName: moduleName!,\n      messagePrefix: errorConfig.messagePrefix,\n    });\n  }\n}\n\nasync function validateFile(\n  root: string,\n  file: OutputChunk,\n  {\n    binaryMapData,\n    moduleResolveMapLocation,\n    logger,\n    workspaceMap,\n  }: {\n    binaryMapData: Record<string, string[]>;\n    moduleResolveMapLocation: string;\n    logger: IMastraLogger;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  try {\n    if (!file.isDynamicEntry && file.isEntry) {\n      // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n      await validate(join(root, file.fileName), {\n        moduleResolveMapLocation,\n        injectESMShim: false,\n      });\n    }\n  } catch (err) {\n    let errorToHandle = err;\n    if (\n      err instanceof ValidationError &&\n      err.type === 'ReferenceError' &&\n      (err.message.startsWith('__dirname') || err.message.startsWith('__filename'))\n    ) {\n      try {\n        await validate(join(root, file.fileName), {\n          moduleResolveMapLocation,\n          injectESMShim: true,\n        });\n        errorToHandle = null;\n      } catch (err) {\n        errorToHandle = err;\n      }\n    }\n\n    if (errorToHandle instanceof Error) {\n      validateError(errorToHandle, file, { binaryMapData, logger, workspaceMap });\n    }\n  }\n}\n\n/**\n * Validates the bundled output by attempting to import each generated module.\n * Tracks external dependencies that couldn't be bundled.\n *\n * @param output - Bundle output from rollup\n * @param reverseVirtualReferenceMap - Map to resolve virtual module names back to original deps\n * @param outputDir - Directory containing the bundled files\n * @param logger - Logger instance for debugging\n * @param workspaceMap - Map of workspace packages that gets directly passed through for later consumption\n * @returns Analysis result containing dependency mappings\n */\nasync function validateOutput(\n  {\n    output,\n    reverseVirtualReferenceMap,\n    usedExternals,\n    outputDir,\n    projectRoot,\n    workspaceMap,\n  }: {\n    output: (OutputChunk | OutputAsset)[];\n    reverseVirtualReferenceMap: Map<string, string>;\n    usedExternals: Record<string, Record<string, string>>;\n    outputDir: string;\n    projectRoot: string;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n  logger: IMastraLogger,\n) {\n  const result = {\n    dependencies: new Map<string, string>(),\n    externalDependencies: new Set<string>(),\n    workspaceMap,\n  };\n\n  // store resolve map for validation\n  // we should resolve the version of the deps\n  for (const deps of Object.values(usedExternals)) {\n    for (const dep of Object.keys(deps)) {\n      result.externalDependencies.add(dep);\n    }\n  }\n  let binaryMapData: Record<string, string[]> = {};\n\n  if (existsSync(join(outputDir, 'binary-map.json'))) {\n    const binaryMap = await readFile(join(outputDir, 'binary-map.json'), 'utf-8');\n    binaryMapData = JSON.parse(binaryMap);\n  }\n\n  for (const file of output) {\n    if (file.type === 'asset') {\n      continue;\n    }\n\n    logger.debug(`Validating if ${file.fileName} is a valid module.`);\n    if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n      result.dependencies.set(reverseVirtualReferenceMap.get(file.name)!, file.fileName);\n    }\n\n    // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n    await validateFile(projectRoot, file, {\n      binaryMapData,\n      moduleResolveMapLocation: join(outputDir, 'module-resolve-map.json'),\n      logger,\n      workspaceMap,\n    });\n  }\n\n  return result;\n}\n\n/**\n * Main bundle analysis function that orchestrates the three-step process:\n * 1. Analyze dependencies\n * 2. Bundle dependencies modules\n * 3. Validate generated bundles\n *\n * This helps identify which dependencies need to be externalized vs bundled.\n */\nexport async function analyzeBundle(\n  entries: string[],\n  mastraEntry: string,\n  {\n    outputDir,\n    projectRoot,\n    isDev = false,\n    bundlerOptions: _bundlerOptions,\n  }: {\n    outputDir: string;\n    projectRoot: string;\n    platform: 'node' | 'browser';\n    isDev?: boolean;\n    bundlerOptions?: {\n      enableEsmShim?: boolean;\n    } | null;\n  },\n  logger: IMastraLogger,\n) {\n  const mastraConfig = await readFile(mastraEntry, 'utf-8');\n  const mastraConfigResult = {\n    hasValidConfig: false,\n  } as const;\n\n  await babel.transformAsync(mastraConfig, {\n    filename: mastraEntry,\n    presets: [import.meta.resolve('@babel/preset-typescript')],\n    plugins: [checkConfigExport(mastraConfigResult)],\n  });\n\n  if (!mastraConfigResult.hasValidConfig) {\n    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:\nexport const mastra = new Mastra({\n  // your options\n})\n  \nIf you think your configuration is valid, please open an issue.`);\n  }\n\n  const { enableEsmShim = true } = _bundlerOptions || {};\n  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);\n  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });\n\n  let index = 0;\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  const { externals: customExternals = [] } = bundlerOptions || {};\n  const allExternals = [...GLOBAL_EXTERNALS, ...customExternals];\n\n  logger.info('Analyzing dependencies...');\n\n  const allUsedExternals = new Set<string>();\n  for (const entry of entries) {\n    const isVirtualFile = entry.includes('\\n') || !existsSync(entry);\n    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {\n      logger,\n      sourcemapEnabled: bundlerOptions?.sourcemap ?? false,\n      workspaceMap,\n      projectRoot,\n      shouldCheckTransitiveDependencies: isDev,\n    });\n\n    // Write the entry file to the output dir so that we can use it for workspace resolution stuff\n    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);\n\n    // Merge dependencies from each entry (main, tools, etc.)\n    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {\n      const isPartOfExternals = allExternals.some(external => isDependencyPartOfPackage(dep, external));\n      if (isPartOfExternals) {\n        allUsedExternals.add(dep);\n        continue;\n      }\n\n      if (depsToOptimize.has(dep)) {\n        // Merge with existing exports if dependency already exists\n        const existingEntry = depsToOptimize.get(dep)!;\n        depsToOptimize.set(dep, {\n          ...existingEntry,\n          exports: [...new Set([...existingEntry.exports, ...metadata.exports])],\n        });\n      } else {\n        depsToOptimize.set(dep, metadata);\n      }\n    }\n  }\n\n  /**\n   * Only during `mastra dev` we want to optimize workspace packages. In previous steps we might have added dependencies that are not workspace packages, so we gotta remove them again.\n   */\n  if (isDev) {\n    for (const [dep, metadata] of depsToOptimize.entries()) {\n      if (!metadata.isWorkspace) {\n        depsToOptimize.delete(dep);\n      }\n    }\n  }\n\n  const sortedDeps = Array.from(depsToOptimize.keys()).sort();\n  logger.info('Optimizing dependencies...');\n  logger.debug(`${sortedDeps.map(key => `- ${key}`).join('\\n')}`);\n\n  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {\n    bundlerOptions: {\n      ...bundlerOptions,\n      externals: allExternals,\n      enableEsmShim,\n      isDev,\n    },\n    projectRoot,\n    workspaceRoot,\n    workspaceMap,\n  });\n\n  const result = await validateOutput(\n    {\n      output,\n      reverseVirtualReferenceMap: fileNameToDependencyMap,\n      usedExternals,\n      outputDir,\n      projectRoot: workspaceRoot || projectRoot,\n      workspaceMap,\n    },\n    logger,\n  );\n\n  return {\n    ...result,\n    externalDependencies: new Set([...result.externalDependencies, ...Array.from(allUsedExternals)]),\n  };\n}\n"]}