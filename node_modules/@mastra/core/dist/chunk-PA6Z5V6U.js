// src/ai-tracing/serialization.ts
var DEFAULT_SERIALIZATION_LIMITS = Object.freeze({
  maxAttrChars: 1024,
  maxDepth: 6,
  maxKeys: 50,
  maxArrayItems: 50,
  maxTotalChars: 8192
});
function truncateString(s, maxChars) {
  if (s.length <= maxChars) return s;
  return s.slice(0, maxChars) + "\u2026[truncated]";
}
var DEFAULT_KEYS_TO_STRIP = /* @__PURE__ */ new Set([
  "logger",
  "experimental_providerMetadata",
  "providerMetadata",
  "steps",
  "tracingContext"
]);
var NO_KEYS_TO_STRIP = /* @__PURE__ */ new Set();
function deepClean(value, options = {}) {
  const {
    keysToStrip = DEFAULT_KEYS_TO_STRIP,
    maxDepth = DEFAULT_SERIALIZATION_LIMITS.maxDepth,
    maxStringLength = DEFAULT_SERIALIZATION_LIMITS.maxAttrChars,
    maxArrayLength = DEFAULT_SERIALIZATION_LIMITS.maxArrayItems,
    maxObjectKeys = DEFAULT_SERIALIZATION_LIMITS.maxKeys
  } = options;
  const seen = /* @__PURE__ */ new WeakSet();
  function helper(val, depth) {
    if (depth > maxDepth) {
      return "[MaxDepth]";
    }
    if (val === null || val === void 0) {
      return val;
    }
    if (typeof val === "string") {
      return truncateString(val, maxStringLength);
    }
    if (typeof val === "number" || typeof val === "boolean") {
      return val;
    }
    if (typeof val === "bigint") {
      return `${val}n`;
    }
    if (typeof val === "function") {
      return "[Function]";
    }
    if (typeof val === "symbol") {
      return val.description ? `[Symbol(${val.description})]` : "[Symbol]";
    }
    if (val instanceof Date) {
      return val;
    }
    if (val instanceof Error) {
      return {
        name: val.name,
        message: val.message ? truncateString(val.message, maxStringLength) : void 0
      };
    }
    if (typeof val === "object") {
      if (seen.has(val)) {
        return "[Circular]";
      }
      seen.add(val);
    }
    if (Array.isArray(val)) {
      const limitedArray = val.slice(0, maxArrayLength);
      const cleaned2 = limitedArray.map((item) => helper(item, depth + 1));
      if (val.length > maxArrayLength) {
        cleaned2.push(`[\u2026${val.length - maxArrayLength} more items]`);
      }
      return cleaned2;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(val)) {
      return `[Buffer length=${val.length}]`;
    }
    if (ArrayBuffer.isView(val)) {
      const ctor = val.constructor?.name ?? "TypedArray";
      const byteLength = val.byteLength ?? "?";
      return `[${ctor} byteLength=${byteLength}]`;
    }
    if (val instanceof ArrayBuffer) {
      return `[ArrayBuffer byteLength=${val.byteLength}]`;
    }
    const cleaned = {};
    const entries = Object.entries(val);
    let keyCount = 0;
    for (const [key, v] of entries) {
      if (keysToStrip.has(key)) {
        continue;
      }
      if (keyCount >= maxObjectKeys) {
        cleaned["__truncated"] = `${entries.length - keyCount} more keys omitted`;
        break;
      }
      try {
        cleaned[key] = helper(v, depth + 1);
        keyCount++;
      } catch (error) {
        cleaned[key] = `[${error instanceof Error ? error.message : String(error)}]`;
        keyCount++;
      }
    }
    return cleaned;
  }
  return helper(value, 0);
}
function boundedStringify(value) {
  const cleaned = deepClean(value, { keysToStrip: NO_KEYS_TO_STRIP });
  try {
    const json = JSON.stringify(cleaned);
    if (json.length > DEFAULT_SERIALIZATION_LIMITS.maxTotalChars) {
      return json.slice(0, DEFAULT_SERIALIZATION_LIMITS.maxTotalChars) + "\u2026[truncated]";
    }
    return json;
  } catch {
    return "[Not Serializable]";
  }
}

export { DEFAULT_KEYS_TO_STRIP, DEFAULT_SERIALIZATION_LIMITS, boundedStringify, deepClean, truncateString };
//# sourceMappingURL=chunk-PA6Z5V6U.js.map
//# sourceMappingURL=chunk-PA6Z5V6U.js.map