{"version":3,"sources":["../src/telemetry/utility.ts","../src/telemetry/telemetry.decorators.ts","../src/telemetry/storage-exporter.ts","../src/telemetry/telemetry.ts"],"names":["trace","propagation","boundedStringify","SpanStatusCode","context","SpanKind","JsonTraceSerializer","acc","TABLE_TRACES","ExportResultCode","MastraError","otlpContext","recordResult","wrappedFn"],"mappings":"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","file":"chunk-7GUQ2EQ4.cjs","sourcesContent":["import { propagation, trace } from '@opentelemetry/api';\nimport type { Context } from '@opentelemetry/api';\n\n// Helper function to check if telemetry is active\nexport function hasActiveTelemetry(tracerName: string = 'default-tracer'): boolean {\n  try {\n    return !!trace.getTracer(tracerName);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get baggage values from context\n * @param ctx The context to get baggage values from\n * @returns\n */\nexport function getBaggageValues(ctx: Context) {\n  const currentBaggage = propagation.getBaggage(ctx);\n  const requestId = currentBaggage?.getEntry('http.request_id')?.value;\n  const componentName = currentBaggage?.getEntry('componentName')?.value;\n  const runId = currentBaggage?.getEntry('runId')?.value;\n  const threadId = currentBaggage?.getEntry('threadId')?.value;\n  const resourceId = currentBaggage?.getEntry('resourceId')?.value;\n  return {\n    requestId,\n    componentName,\n    runId,\n    threadId,\n    resourceId,\n  };\n}\n","import { context, propagation, SpanKind, SpanStatusCode, trace } from '@opentelemetry/api';\nimport type { Span } from '@opentelemetry/api';\n\nimport { boundedStringify } from '../ai-tracing/serialization';\nimport { getBaggageValues, hasActiveTelemetry } from './utility';\n\ninterface StreamFinishData {\n  text?: string;\n  usage?: {\n    // AI SDK v5 format (VNext paths)\n    inputTokens?: number;\n    outputTokens?: number;\n    reasoningTokens?: number;\n    cachedInputTokens?: number;\n    // Legacy format (backward compatibility)\n    promptTokens?: number;\n    completionTokens?: number;\n    // Common fields\n    totalTokens?: number;\n  };\n  finishReason?: string;\n  toolCalls?: unknown[];\n  toolResults?: unknown[];\n  warnings?: unknown;\n  object?: unknown; // structured output\n}\n\ninterface StreamOptions {\n  onFinish?: (data: StreamFinishData) => Promise<void> | void;\n  [key: string]: unknown;\n}\n\ninterface EnhancedSpan extends Span {\n  __mastraStreamingSpan?: boolean;\n  __mastraEnded?: boolean;\n}\n\n/**\n * End a span at most once (guards against double-end bugs across layers).\n */\nfunction endSpanOnce(span: EnhancedSpan) {\n  if (span.__mastraEnded) return;\n  span.__mastraEnded = true;\n  try {\n    span.end();\n  } catch {\n    // best-effort\n  }\n}\n\nfunction isStreamingMethod(methodName: string): boolean {\n  return methodName === 'stream' || methodName === 'streamLegacy';\n}\n\n/**\n * Attach minimal finish data to a span for streaming methods.\n * Default behavior stores only SMALL summary fields to avoid OOM.\n */\nfunction enhanceStreamingArgumentsWithTelemetry(args: unknown[], span: EnhancedSpan, spanName: string): unknown[] {\n  const enhancedArgs = [...args];\n\n  // Helper to check if value is a plain object\n  const isPlainObject = (val: unknown): val is Record<string, unknown> =>\n    val !== null && typeof val === 'object' && !Array.isArray(val);\n\n  // Create the enhanced onFinish callback\n  const createEnhancedOnFinish = (originalOnFinish?: (data: StreamFinishData) => Promise<void> | void) => {\n    const enhancedOnFinish = async (finishData: StreamFinishData) => {\n      const telemetryData = {\n        text: finishData.text,\n        usage: finishData.usage,\n        finishReason: finishData.finishReason,\n        toolCalls: finishData.toolCalls,\n        toolResults: finishData.toolResults,\n        warnings: finishData.warnings,\n        ...(finishData.object !== undefined && { object: finishData.object }),\n      };\n\n      span.setAttribute(`${spanName}.result`, boundedStringify(telemetryData));\n      span.setStatus({ code: SpanStatusCode.OK });\n      endSpanOnce(span);\n\n      if (originalOnFinish) return await originalOnFinish(finishData);\n    };\n    (enhancedOnFinish as any).__hasOriginalOnFinish = !!originalOnFinish;\n    return enhancedOnFinish;\n  };\n\n  // Case 1: Single object argument (e.g., TTS.stream({ text }))\n  if (enhancedArgs.length === 1 && isPlainObject(enhancedArgs[0])) {\n    const singleArg = enhancedArgs[0] as StreamOptions;\n    const originalOnFinish = singleArg.onFinish;\n    enhancedArgs[0] = {\n      ...singleArg,\n      onFinish: createEnhancedOnFinish(originalOnFinish),\n    };\n  }\n  // Case 2: Two-argument signature (model/prompt, options?)\n  else {\n    const streamOptions =\n      enhancedArgs.length > 1 && isPlainObject(enhancedArgs[1]) ? (enhancedArgs[1] as StreamOptions) : {};\n    const originalOnFinish = streamOptions.onFinish;\n    enhancedArgs[1] = {\n      ...streamOptions,\n      onFinish: createEnhancedOnFinish(originalOnFinish),\n    };\n  }\n\n  span.__mastraStreamingSpan = true;\n  return enhancedArgs;\n}\n\n// Decorator factory\nexport function withSpan(options: {\n  spanName?: string;\n  skipIfNoTelemetry?: boolean;\n  spanKind?: SpanKind;\n  tracerName?: string;\n}): any {\n  return function (_target: any, propertyKey: string | symbol, descriptor?: PropertyDescriptor | number) {\n    if (!descriptor || typeof descriptor === 'number') return;\n\n    const originalMethod = descriptor.value as Function;\n    const methodName = String(propertyKey);\n\n    descriptor.value = function (this: unknown, ...args: unknown[]) {\n      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {\n        return originalMethod.apply(this, args);\n      }\n\n      const tracer = trace.getTracer(options?.tracerName ?? 'default-tracer');\n\n      // Determine span name and kind\n      let spanName: string;\n      let spanKind: SpanKind | undefined;\n\n      if (typeof options === 'string') {\n        spanName = options;\n      } else if (options) {\n        spanName = options.spanName || methodName;\n        spanKind = options.spanKind;\n      } else {\n        spanName = methodName;\n      }\n\n      // Start the span with optional kind\n      const span = tracer.startSpan(spanName, { kind: spanKind }) as EnhancedSpan;\n\n      // Always bind span to the active context\n      let ctx = trace.setSpan(context.active(), span);\n\n      // Record input arguments with bounded serialization\n      args.forEach((arg, index) => {\n        span.setAttribute(`${spanName}.argument.${index}`, boundedStringify(arg));\n      });\n\n      // Attach baggage-derived fields (these should be small)\n      const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);\n\n      if (requestId) {\n        span.setAttribute('http.request_id', requestId);\n      }\n\n      if (threadId) {\n        span.setAttribute('threadId', threadId);\n      }\n\n      if (resourceId) {\n        span.setAttribute('resourceId', resourceId);\n      }\n\n      if (componentName) {\n        span.setAttribute('componentName', componentName);\n        if (runId) {\n          span.setAttribute('runId', runId);\n        }\n      } else if (this && typeof this === 'object' && 'name' in this) {\n        const contextObj = this as { name: string; runId?: string };\n        span.setAttribute('componentName', contextObj.name);\n        if (contextObj.runId) span.setAttribute('runId', contextObj.runId);\n\n        // Best-effort baggage update, but do NOT inject undefined properties\n        const baggageEntries: Record<string, { value: string }> = {};\n\n        baggageEntries.componentName = { value: contextObj.name };\n\n        if (contextObj.runId) {\n          baggageEntries.runId = { value: contextObj.runId };\n        }\n\n        if (requestId) {\n          baggageEntries['http.request_id'] = { value: requestId };\n        }\n\n        if (threadId) {\n          baggageEntries.threadId = { value: threadId };\n        }\n\n        if (resourceId) {\n          baggageEntries.resourceId = { value: resourceId };\n        }\n\n        ctx = propagation.setBaggage(ctx, propagation.createBaggage(baggageEntries as any));\n      }\n\n      try {\n        // If this is a streaming method, wrap args before invocation\n        const enhancedArgs = isStreamingMethod(methodName)\n          ? enhanceStreamingArgumentsWithTelemetry(args, span, spanName)\n          : args;\n\n        const result = context.with(ctx, () => originalMethod.apply(this, enhancedArgs));\n\n        // Promise\n        if (result instanceof Promise) {\n          return result\n            .then(resolvedValue => {\n              // For streaming, onFinish is responsible for ending span\n              if (isStreamingMethod(methodName)) {\n                return resolvedValue;\n              }\n\n              span.setAttribute(`${spanName}.result`, boundedStringify(resolvedValue));\n              span.setStatus({ code: SpanStatusCode.OK });\n              return resolvedValue;\n            })\n            .catch(err => {\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err instanceof Error ? err.message : 'Unknown error',\n              });\n              if (err instanceof Error) {\n                // recordException is okay, but can include stack; rely on OTel/Sentry settings\n                span.recordException(err);\n              }\n              // End span on error - for streaming methods, onFinish won't be called if there's an error\n              endSpanOnce(span);\n              throw err;\n            })\n            .finally(() => {\n              if (!span.__mastraStreamingSpan) endSpanOnce(span);\n            });\n        }\n\n        // Non-promise return\n        if (!isStreamingMethod(methodName)) {\n          span.setAttribute(`${spanName}.result`, boundedStringify(result));\n        }\n        span.setStatus({ code: SpanStatusCode.OK });\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : 'Unknown error',\n        });\n        if (error instanceof Error) {\n          span.recordException(error);\n        }\n        // End span on error - for streaming methods, onFinish won't be called if there's an error\n        endSpanOnce(span);\n        throw error;\n      } finally {\n        // End span for sync non-streaming methods (streaming ends in onFinish or catch)\n        if (!isStreamingMethod(methodName) && !span.__mastraEnded) {\n          endSpanOnce(span);\n        }\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n// class-telemetry.decorator.ts\nexport function InstrumentClass(options?: {\n  prefix?: string;\n  spanKind?: SpanKind;\n  excludeMethods?: string[];\n  methodFilter?: (methodName: string) => boolean;\n  tracerName?: string;\n}) {\n  return function (target: any) {\n    const methods = Object.getOwnPropertyNames(target.prototype);\n\n    methods.forEach(method => {\n      if (options?.excludeMethods?.includes(method) || method === 'constructor') return;\n      if (options?.methodFilter && !options.methodFilter(method)) return;\n\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);\n      if (descriptor && typeof descriptor.value === 'function') {\n        Object.defineProperty(\n          target.prototype,\n          method,\n          withSpan({\n            spanName: options?.prefix ? `${options.prefix}.${method}` : method,\n            skipIfNoTelemetry: true,\n            spanKind: options?.spanKind || SpanKind.INTERNAL,\n            tracerName: options?.tracerName,\n          })(target, method, descriptor),\n        );\n      }\n    });\n\n    return target;\n  };\n}\n","import { ExportResultCode } from '@opentelemetry/core';\nimport type { ExportResult } from '@opentelemetry/core';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport type { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\n\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { IMastraLogger } from '../logger';\nimport type { MastraStorage } from '../storage/base';\nimport { TABLE_TRACES } from '../storage/constants';\n\nexport class OTLPTraceExporter implements SpanExporter {\n  private storage: MastraStorage;\n  private queue: { data: any[]; resultCallback: (result: ExportResult) => void }[] = [];\n  private serializer: typeof JsonTraceSerializer;\n  private logger: IMastraLogger;\n  private activeFlush: Promise<void> | undefined = undefined;\n\n  constructor({ logger, storage }: { logger: IMastraLogger; storage: MastraStorage }) {\n    this.storage = storage;\n    this.serializer = JsonTraceSerializer;\n    this.logger = logger;\n  }\n\n  export(internalRepresentation: ReadableSpan[], resultCallback: (result: ExportResult) => void): void {\n    const serializedRequest = this.serializer.serializeRequest(internalRepresentation);\n    // @ts-ignore\n    const payload = JSON.parse(Buffer.from(serializedRequest.buffer, 'utf8'));\n    const items = payload?.resourceSpans?.[0]?.scopeSpans;\n    this.logger.debug(`Exporting telemetry: ${items.length} scope spans to be processed [trace batch]`);\n\n    this.queue.push({ data: items, resultCallback });\n\n    if (!this.activeFlush) {\n      this.activeFlush = this.flush();\n    }\n  }\n  shutdown(): Promise<void> {\n    return this.forceFlush();\n  }\n\n  flush(): Promise<void> {\n    const now = new Date();\n    const items = this.queue.shift();\n    if (!items) return Promise.resolve();\n\n    const allSpans: any[] = items.data.reduce((acc, scopedSpans) => {\n      const { scope, spans } = scopedSpans;\n      for (const span of spans) {\n        const {\n          spanId,\n          parentSpanId,\n          traceId,\n          name,\n          kind,\n          attributes,\n          status,\n          events,\n          links,\n          startTimeUnixNano,\n          endTimeUnixNano,\n          ...rest\n        } = span;\n\n        const startTime = Number(BigInt(startTimeUnixNano) / 1000n);\n        const endTime = Number(BigInt(endTimeUnixNano) / 1000n);\n\n        acc.push({\n          id: spanId,\n          parentSpanId,\n          traceId,\n          name,\n          scope: scope.name,\n          kind,\n          status: JSON.stringify(status),\n          events: JSON.stringify(events),\n          links: JSON.stringify(links),\n          attributes: JSON.stringify(\n            attributes.reduce((acc: Record<string, any>, attr: any) => {\n              const valueKey = Object.keys(attr.value)[0];\n              if (valueKey) {\n                acc[attr.key] = attr.value[valueKey];\n              }\n              return acc;\n            }, {}),\n          ),\n          startTime,\n          endTime,\n          other: JSON.stringify(rest),\n          createdAt: now,\n        });\n      }\n      return acc;\n    }, []);\n\n    return this.storage\n      .batchInsert({\n        tableName: TABLE_TRACES,\n        records: allSpans,\n      })\n      .then(() => {\n        items.resultCallback({\n          code: ExportResultCode.SUCCESS,\n        });\n      })\n      .catch(e => {\n        const mastraError = new MastraError(\n          {\n            id: 'OTLP_TRACE_EXPORT_FAILURE',\n            text: 'Failed to export telemetry spans',\n            domain: ErrorDomain.MASTRA_TELEMETRY,\n            category: ErrorCategory.SYSTEM,\n            details: {\n              attemptedSpanCount: allSpans.length,\n              targetTable: TABLE_TRACES,\n              firstSpanName: allSpans.length > 0 ? allSpans[0].name : '',\n              firstSpanKind: allSpans.length > 0 ? allSpans[0].kind : '',\n              firstSpanScope: allSpans.length > 0 ? allSpans[0].scope : '',\n            },\n          },\n          e,\n        );\n        this.logger.trackException(mastraError);\n        this.logger.error('span err:' + mastraError.toString());\n        items.resultCallback({\n          code: ExportResultCode.FAILED,\n          error: e,\n        });\n      })\n      .finally(() => {\n        this.activeFlush = undefined;\n      });\n  }\n  async forceFlush(): Promise<void> {\n    if (!this.queue.length) {\n      return;\n    }\n\n    await this.activeFlush;\n    while (this.queue.length) {\n      await this.flush();\n    }\n  }\n\n  __setLogger(logger: IMastraLogger) {\n    this.logger = logger;\n  }\n}\n","import { context as otlpContext, SpanStatusCode, trace, propagation, context } from '@opentelemetry/api';\nimport type { Tracer, SpanOptions, Context, Span, BaggageEntry } from '@opentelemetry/api';\n\nimport { boundedStringify } from '../ai-tracing/serialization';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { OtelConfig } from './types';\nimport { getBaggageValues, hasActiveTelemetry } from './utility';\n\n// Add type declaration for global namespace\ndeclare global {\n  var __TELEMETRY__: Telemetry | undefined;\n}\n\nexport class Telemetry {\n  public tracer: Tracer = trace.getTracer('default');\n  name: string = 'default-service';\n\n  private constructor(config: OtelConfig) {\n    this.name = config.serviceName ?? 'default-service';\n\n    this.tracer = trace.getTracer(this.name);\n  }\n\n  /**\n   * @deprecated This method does not do anything\n   */\n  public async shutdown() {}\n\n  /**\n   * Initialize telemetry with the given configuration\n   * @param config - Optional telemetry configuration object\n   * @returns Telemetry instance that can be used for tracing\n   */\n  static init(config: OtelConfig = {}): Telemetry {\n    try {\n      if (!globalThis.__TELEMETRY__) {\n        globalThis.__TELEMETRY__ = new Telemetry(config);\n      }\n\n      return globalThis.__TELEMETRY__;\n    } catch (error) {\n      const wrappedError = new MastraError(\n        {\n          id: 'TELEMETRY_INIT_FAILED',\n          text: 'Failed to initialize telemetry',\n          domain: ErrorDomain.MASTRA_TELEMETRY,\n          category: ErrorCategory.SYSTEM,\n        },\n        error,\n      );\n      throw wrappedError;\n    }\n  }\n\n  static getActiveSpan() {\n    const span = trace.getActiveSpan();\n    return span;\n  }\n\n  /**\n   * Get the global telemetry instance\n   * @throws {Error} If telemetry has not been initialized\n   * @returns {Telemetry} The global telemetry instance\n   */\n  static get(): Telemetry {\n    if (!globalThis.__TELEMETRY__) {\n      throw new MastraError({\n        id: 'TELEMETRY_GETTER_FAILED_GLOBAL_TELEMETRY_NOT_INITIALIZED',\n        text: 'Telemetry not initialized',\n        domain: ErrorDomain.MASTRA_TELEMETRY,\n        category: ErrorCategory.USER,\n      });\n    }\n    return globalThis.__TELEMETRY__;\n  }\n\n  /**\n   * Wraps a class instance with telemetry tracing\n   * @param instance The class instance to wrap\n   * @param options Optional configuration for tracing\n   * @returns Wrapped instance with all methods traced\n   */\n  traceClass<T extends object>(\n    instance: T,\n    options: {\n      /** Base name for spans (e.g. 'integration', 'agent') */\n      spanNamePrefix?: string;\n      /** Additional attributes to add to all spans */\n      attributes?: Record<string, string>;\n      /** Methods to exclude from tracing */\n      excludeMethods?: string[];\n      /** Skip tracing if telemetry is not active */\n      skipIfNoTelemetry?: boolean;\n    } = {},\n  ): T {\n    const { skipIfNoTelemetry = true } = options;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return instance;\n    }\n\n    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;\n\n    return new Proxy(instance, {\n      get: (target, prop: string | symbol) => {\n        const value = target[prop as keyof T];\n\n        // Skip tracing for excluded methods, constructors, private methods\n        if (\n          typeof value === 'function' &&\n          prop !== 'constructor' &&\n          !prop.toString().startsWith('_') &&\n          !excludeMethods.includes(prop.toString())\n        ) {\n          return this.traceMethod(value.bind(target), {\n            spanName: `${spanNamePrefix}.${prop.toString()}`,\n            attributes: {\n              ...attributes,\n              [`${spanNamePrefix}.name`]: target.constructor.name,\n              [`${spanNamePrefix}.method.name`]: prop.toString(),\n            },\n          });\n        }\n\n        return value;\n      },\n    });\n  }\n\n  static setBaggage(baggage: Record<string, BaggageEntry>, ctx: Context = otlpContext.active()) {\n    const currentBaggage = Object.fromEntries(propagation.getBaggage(ctx)?.getAllEntries() ?? []);\n    const newCtx = propagation.setBaggage(\n      ctx,\n      propagation.createBaggage({\n        ...currentBaggage,\n        ...baggage,\n      }),\n    );\n    return newCtx;\n  }\n\n  static withContext(ctx: Context, fn: () => void) {\n    return otlpContext.with(ctx, fn);\n  }\n\n  /**\n   * method to trace individual methods with proper context\n   * @param method The method to trace\n   * @param context Additional context for the trace\n   * @returns Wrapped method with tracing\n   */\n  traceMethod<TMethod extends Function>(\n    method: TMethod,\n    context: {\n      spanName: string;\n      attributes?: Record<string, string>;\n      skipIfNoTelemetry?: boolean;\n      parentSpan?: Span;\n    },\n  ): TMethod {\n    let ctx = otlpContext.active();\n    const { skipIfNoTelemetry = true } = context;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return method;\n    }\n\n    return ((...args: unknown[]) => {\n      const span = this.tracer.startSpan(context.spanName);\n\n      function handleError(error: unknown) {\n        span.recordException(error as Error);\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: (error as Error).message,\n        });\n        span.end();\n        throw error;\n      }\n      try {\n        const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);\n\n        // Add all context attributes to span\n        if (context.attributes) {\n          span.setAttributes(context.attributes);\n        }\n\n        if (requestId) {\n          span.setAttribute('http.request_id', requestId);\n        }\n\n        if (threadId) {\n          span.setAttribute('threadId', threadId);\n        }\n\n        if (resourceId) {\n          span.setAttribute('resourceId', resourceId);\n        }\n\n        if (context.attributes?.componentName) {\n          ctx = propagation.setBaggage(\n            ctx,\n            propagation.createBaggage({\n              componentName: { value: context.attributes.componentName },\n              // @ts-ignore\n              runId: { value: context.attributes.runId },\n              // @ts-ignore\n              'http.request_id': { value: requestId },\n            }),\n          );\n        } else {\n          if (componentName) {\n            span.setAttribute('componentName', componentName);\n            // @ts-ignore\n            span.setAttribute('runId', runId);\n          } else if (this && this.name) {\n            span.setAttribute('componentName', this.name);\n            // @ts-ignore\n            span.setAttribute('runId', this.runId);\n            ctx = propagation.setBaggage(\n              ctx,\n              propagation.createBaggage({\n                componentName: { value: this.name },\n                // @ts-ignore\n                runId: { value: this.runId },\n                // @ts-ignore\n                'http.request_id': { value: requestId },\n                // @ts-ignore\n                threadId: { value: threadId },\n                // @ts-ignore\n                resourceId: { value: resourceId },\n              }),\n            );\n          }\n        }\n\n        // Record input arguments as span attributes (with bounded serialization)\n        args.forEach((arg, index) => {\n          span.setAttribute(`${context.spanName}.argument.${index}`, boundedStringify(arg));\n        });\n\n        let result: any;\n        otlpContext.with(trace.setSpan(ctx, span), () => {\n          result = method(...args);\n        });\n\n        function recordResult(res: any) {\n          span.setAttribute(`${context.spanName}.result`, boundedStringify(res));\n          span.end();\n          return res;\n        }\n\n        if (result instanceof Promise) {\n          return result.then(recordResult).catch(handleError);\n        } else {\n          return recordResult(result);\n        }\n      } catch (error) {\n        handleError(error);\n      }\n    }) as unknown as TMethod;\n  }\n\n  getBaggageTracer(): Tracer {\n    return new BaggageTracer(this.tracer);\n  }\n}\n\nclass BaggageTracer implements Tracer {\n  private _tracer: Tracer;\n\n  constructor(tracer: Tracer) {\n    this._tracer = tracer;\n  }\n\n  startSpan(name: string, options: SpanOptions = {}, ctx: Context) {\n    ctx = ctx ?? otlpContext.active();\n    const span = this._tracer.startSpan(name, options, ctx);\n    const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(ctx);\n    // @ts-ignore\n    span.setAttribute('componentName', componentName);\n    // @ts-ignore\n    span.setAttribute('runId', runId);\n    // @ts-ignore\n    span.setAttribute('http.request_id', requestId);\n    // @ts-ignore\n    span.setAttribute('threadId', threadId);\n    // @ts-ignore\n    span.setAttribute('resourceId', resourceId);\n\n    return span;\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, options: SpanOptions, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    options: SpanOptions,\n    ctx: Context,\n    fn: F,\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    optionsOrFn: SpanOptions | F,\n    ctxOrFn?: Context | F,\n    fn?: F,\n  ): ReturnType<F> {\n    if (typeof optionsOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', componentName);\n        // @ts-ignore\n        span.setAttribute('runId', runId);\n        // @ts-ignore\n        span.setAttribute('http.request_id', requestId);\n        // @ts-ignore\n        span.setAttribute('threadId', threadId);\n        // @ts-ignore\n        span.setAttribute('resourceId', resourceId);\n\n        return optionsOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, {}, context.active(), wrappedFn as F);\n    }\n    if (typeof ctxOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', componentName);\n        // @ts-ignore\n        span.setAttribute('runId', runId);\n        // @ts-ignore\n        span.setAttribute('http.request_id', requestId);\n        // @ts-ignore\n        span.setAttribute('threadId', threadId);\n        // @ts-ignore\n        span.setAttribute('resourceId', resourceId);\n\n        return ctxOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, optionsOrFn, context.active(), wrappedFn as F);\n    }\n    const wrappedFn = (span: Span) => {\n      const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(\n        ctxOrFn ?? otlpContext.active(),\n      );\n      // @ts-ignore\n      span.setAttribute('componentName', componentName);\n      // @ts-ignore\n      span.setAttribute('runId', runId);\n      // @ts-ignore\n      span.setAttribute('http.request_id', requestId);\n      // @ts-ignore\n      span.setAttribute('threadId', threadId);\n      // @ts-ignore\n      span.setAttribute('resourceId', resourceId);\n\n      return fn!(span);\n    };\n    return this._tracer.startActiveSpan(name, optionsOrFn, ctxOrFn!, wrappedFn as F);\n  }\n}\n"]}